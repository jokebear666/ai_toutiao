"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4240],{28453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var i=s(96540);const r={},t=i.createContext(r);function a(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(t.Provider,{value:n},e.children)}},71457:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"daily/cs_FL/20251229-20260104","title":"20251229-20260104 (cs.FL)","description":"2025-12-29","source":"@site/docs/daily/cs_FL/20251229-20260104.md","sourceDirName":"daily/cs_FL","slug":"/daily/csfl/20251229-20260104","permalink":"/ai_toutiao/daily/csfl/20251229-20260104","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767100119000,"frontMatter":{"slug":"/daily/csfl/20251229-20260104"},"sidebar":"tutorialSidebar","previous":{"title":"20251222-20251228 (cs.FL)","permalink":"/ai_toutiao/daily/csfl/20251222-20251228"},"next":{"title":"cs.GR","permalink":"/ai_toutiao/category/csgr"}}');var r=s(74848),t=s(28453);const a={slug:"/daily/csfl/20251229-20260104"},o="20251229-20260104 (cs.FL)",l={},c=[{value:"2025-12-29",id:"2025-12-29",level:2},{value:"2025-12-30",id:"2025-12-30",level:2}];function d(e){const n={a:"a",annotation:"annotation",h1:"h1",h2:"h2",header:"header",li:"li",math:"math",mermaid:"mermaid",mi:"mi",mrow:"mrow",p:"p",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"20251229-20260104-csfl",children:"20251229-20260104 (cs.FL)"})}),"\n",(0,r.jsx)(n.h2,{id:"2025-12-29",children:"2025-12-29"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"[arXiv251229] Quantitative Verification of Omega-regular Properties in Probabilistic Programming"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [other], [probabilistic programming and verification], [temporal posterior inference, omega-regular properties, stochastic barrier certificates, Rabin automata, quantitative verification]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Peixin Wang, Jianhao Bai, Min Zhang, C.-H. Luke Ong"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," East China Normal University, Nanyang Technological University"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.21596",children:"https://arxiv.org/pdf/2512.21596"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Introduces Temporal Posterior Inference (TPI), a new framework unifying probabilistic programming with temporal logic to compute posterior distributions over execution traces satisfying omega-regular properties. 2. Develops a novel method for computing rigorous upper and lower bounds on satisfaction probabilities by decomposing Rabin acceptance conditions and constructing sound stochastic barrier certificates. 3. Implements the approach in a prototype tool named TPInfer and demonstrates its effectiveness and efficiency on a suite of benchmarks."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/c111a01f9d5e96a85d9b5c62645dae0f5bb40053d723e34cb57dc7f31554dcda_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/c111a01f9d5e96a85d9b5c62645dae0f5bb40053d723e34cb57dc7f31554dcda_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper addresses the limitation of standard probabilistic program inference, which fails to capture temporal behavior, by proposing Temporal Posterior Inference (TPI). TPI computes posterior distributions over program traces that satisfy omega-regular temporal specifications, using a method based on stochastic barrier certificates to provide quantitative verification bounds. The approach is implemented in the TPInfer tool and shown to be effective for inference over rich temporal properties."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:'graph TB\n    Root("Quantitative Verification of Omega-regular Properties in Probabilistic Programming") --\x3e Problem("\u6838\u5fc3\u95ee\u9898/Problem")\n    Root --\x3e Method("\u4e3b\u8981\u65b9\u6cd5/Method")\n    Root --\x3e Results("\u5173\u952e\u7ed3\u679c/Results")\n    Problem --\x3e P1("\u6807\u51c6\u540e\u9a8c\u63a8\u65ad\u7684\u5c40\u9650/Limitation of Standard Posterior Inference")\n    P1 --\x3e P2("\u65e0\u6cd5\u6355\u6349\u7a0b\u5e8f\u6267\u884c\u7684\u65f6\u95f4\u6f14\u5316/Fails to capture temporal evolution")\n    Method --\x3e M1("\u63d0\u51fa\u65f6\u95f4\u540e\u9a8c\u63a8\u65ad\u6846\u67b6/Propose Temporal Posterior Inference (TPI)")\n    M1 --\x3e M2("\u7edf\u4e00\u6982\u7387\u7f16\u7a0b\u4e0e\u65f6\u5e8f\u903b\u8f91/Unifies Probabilistic Programming & Temporal Logic")\n    M2 --\x3e M3("\u57fa\u4e8e\u968f\u673a\u5c4f\u969c\u8bc1\u4e66\u7684\u5b9a\u91cf\u9a8c\u8bc1\u65b9\u6cd5/Quantitative Verification via Stochastic Barrier Certificates")\n    Results --\x3e R1("\u5b9e\u73b0\u539f\u578b\u5de5\u5177 TPInfer/Implement Prototype Tool TPInfer")\n    Results --\x3e R2("\u5728\u57fa\u51c6\u6d4b\u8bd5\u4e2d\u5c55\u793a\u6709\u6548\u6027\u4e0e\u6548\u7387/Demonstrates Effectiveness & Efficiency on Benchmarks")'}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"2025-12-30",children:"2025-12-30"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251230] Monadic Context Engineering"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [mlsys], [agent system], [Monadic Context Engineering, Monad Transformers, Meta-Agents, computational contexts, algebraic structures]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Yifan Zhang, Mengdi Wang"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," Princeton University"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.22431",children:"https://arxiv.org/pdf/2512.22431"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"code:"})," ",(0,r.jsx)(n.a,{href:"https://github.com/yifanzhang-pro/monadic-context-engineering",children:"https://github.com/yifanzhang-pro/monadic-context-engineering"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Proposes Monadic Context Engineering (MCE), a novel architectural paradigm using Functors, Applicatives, and Monads to provide a formal foundation for AI agent design. 2. Demonstrates how Monads and Applicatives manage sequential composition and parallel execution, and how Monad Transformers enable systematic composition of capabilities like state and error handling. 3. Extends the MCE framework to describe Meta-Agents for generative orchestration, dynamically creating and managing sub-agent workflows via metaprogramming."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/635ff6dca4b79fe5e98a96641cbb26356935e3090aa65b20972b744e69151810_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/635ff6dca4b79fe5e98a96641cbb26356935e3090aa65b20972b744e69151810_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper addresses the brittleness and complexity in current AI agent architectures by introducing Monadic Context Engineering (MCE), a paradigm that leverages algebraic structures like Monads to formally manage state, errors, and concurrency within agent workflows. The proposed method enables the construction of complex, resilient agents from simple, verifiable components and is extended to support generative orchestration via Meta-Agents. The work concludes that MCE provides a principled foundation for building robust and scalable autonomous agent systems."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:'graph TB\n    Root["Monadic Context Engineering"] --\x3e Problem["\u6838\u5fc3\u95ee\u9898/Problem"]\n    Root --\x3e Method["\u4e3b\u8981\u65b9\u6cd5/Method"]\n    Root --\x3e Results["\u5173\u952e\u7ed3\u679c/Results"]\n    Problem --\x3e P1["\u5f53\u524d\u4ee3\u7406\u67b6\u6784\u8106\u5f31/Current agent architectures are brittle"]\n    Problem --\x3e P2["\u72b6\u6001\u3001\u9519\u8bef\u3001\u5e76\u53d1\u7ba1\u7406\u56f0\u96be/Difficulties in state, error, concurrency management"]\n    Method --\x3e M1["\u5f15\u5165\u5355\u5b50\u4e0a\u4e0b\u6587\u5de5\u7a0b/Introduce Monadic Context Engineering (MCE)"]\n    Method --\x3e M2["\u5229\u7528\u51fd\u5b50\u3001\u5e94\u7528\u51fd\u5b50\u3001\u5355\u5b50/Leverage Functors, Applicatives, Monads"]\n    Method --\x3e M3["\u4f7f\u7528\u5355\u5b50\u53d8\u6362\u5668\u7ec4\u5408\u80fd\u529b/Use Monad Transformers to compose capabilities"]\n    Results --\x3e R1["\u63d0\u4f9b\u5f62\u5f0f\u5316\u57fa\u7840/Provides a formal foundation"]\n    Results --\x3e R2["\u652f\u6301\u6784\u5efa\u590d\u6742\u3001\u9c81\u68d2\u7684\u4ee3\u7406/Enables building complex, resilient agents"]\n    Results --\x3e R3["\u6269\u5c55\u81f3\u5143\u4ee3\u7406\u8fdb\u884c\u751f\u6210\u5f0f\u7f16\u6392/Extends to Meta-Agents for generative orchestration"]'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251230] Spatio-Temporal view on the Topological Functioning Model"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [se], [formal methods], [Topological Functioning Model, spatio-temporal analysis, model-driven software engineering]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Maria Spichkova"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," RMIT University"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.22889",children:"https://arxiv.org/pdf/2512.22889"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Proposes the TopFunST framework for analyzing topological dependencies among system features, 2. Extends the Topological Functioning Model (TFM) language to incorporate spatial and temporal aspects, 3. Addresses a key limitation of existing TFM approaches which previously did not cover spatio-temporal properties."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/2b6637b22511044d930f9ddb6d7160c56c34b592145078a9f09501402634d984_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/2b6637b22511044d930f9ddb6d7160c56c34b592145078a9f09501402634d984_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper addresses the lack of spatial and temporal analysis in Topological Functioning Models (TFM). It proposes the TopFunST framework, which extends the TFM language to cover these aspects, enabling a more comprehensive analysis of system feature dependencies and interactions."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:'graph TB\n    Root["Spatio-Temporal view on the Topological Functioning Model<br>\u62d3\u6251\u529f\u80fd\u6a21\u578b\u7684\u65f6\u7a7a\u89c6\u56fe"] --\x3e Problem\n    Root --\x3e Method\n    Root --\x3e Results\n    Problem["TFM lacks spatio-temporal analysis<br>TFM\u7f3a\u4e4f\u65f6\u7a7a\u5206\u6790"] --\x3e P1["Spatial & temporal aspects are crucial<br>\u65f6\u7a7a\u65b9\u9762\u81f3\u5173\u91cd\u8981"]\n    Method["Proposes TopFunST framework<br>\u63d0\u51faTopFunST\u6846\u67b6"] --\x3e M1["Extends TFM language<br>\u6269\u5c55TFM\u8bed\u8a00"]\n    Results["Enables spatio-temporal dependency analysis<br>\u5b9e\u73b0\u65f6\u7a7a\u4f9d\u8d56\u5206\u6790"] --\x3e R1["Covers a limitation of TFM<br>\u8986\u76d6\u4e86TFM\u7684\u4e00\u4e2a\u5c40\u9650"]'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251230] Verifying Asynchronous Hyperproperties in Reactive Systems"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [sec], [formal verification], [asynchronous hyperproperties, HyperLTL, model checking, game semantics, observational determinism]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Raven Beutner, Bernd Finkbeiner"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," CISPA Helmholtz Center for Information Security"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.23344",children:"https://arxiv.org/pdf/2512.23344"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Proposes a novel game-based approach for verifying arbitrary \u2200\u2217\u2203\u2217 formulas in Asynchronous HyperLTL (A-HLTL) in reactive systems. 2. Interprets verification as a game between a verifier and refuter, where a winning strategy provides witnesses for traces and asynchronous alignments for stutterings. 3. Identifies fragments for which the game-based interpretation is complete, providing a finite-state decision procedure, and contributes a prototype implementation with encouraging experimental results."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/0e321908ac7277c8c91e3b8e509efae3be66dbe7c391e613f19a6ca343db4f16_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/0e321908ac7277c8c91e3b8e509efae3be66dbe7c391e613f19a6ca343db4f16_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper addresses the challenge of model-checking asynchronous hyperproperties in reactive systems, which require comparing execution traces across different timesteps. It proposes a novel game-based verification method for a logic called Asynchronous HyperLTL (A-HLTL), interpreting the problem as a two-player game to find suitable trace stutterings. The approach provides a decision procedure for certain formula fragments and is supported by a prototype implementation."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TB\n    Root[Verifying Asynchronous Hyperproperties in Reactive Systems] --\x3e Problem\n    Root --\x3e Method\n    Root --\x3e Results\n    Problem[\u6838\u5fc3\u95ee\u9898/Problem] --\x3e P1[\u540c\u6b65HyperLTL\u65e0\u6cd5\u8868\u8fbe\u5f02\u6b65\u8d85\u5c5e\u6027/Synchronous HyperLTL cannot express asynchronous hyperproperties]\n    Problem --\x3e P2[\u73b0\u6709\u65b9\u6cd5\u9650\u5236\u4e8e\u53d7\u9650\u7247\u6bb5\u6216\u7ec8\u6b62\u7cfb\u7edf/Existing methods limited to restricted fragments or terminating systems]\n    Method[\u4e3b\u8981\u65b9\u6cd5/Method] --\x3e M1[\u63d0\u51fa\u57fa\u4e8e\u6e38\u620f\u7684\u9a8c\u8bc1\u65b9\u6cd5/Propose a game-based verification approach]\n    Method --\x3e M2[\u9a8c\u8bc1\u8005\u4e0e\u53cd\u9a73\u8005\u7684\u53cc\u4eba\u6e38\u620f/Two-player game between verifier and refuter]\n    Method --\x3e M3[\u83b7\u80dc\u7b56\u7565\u5bf9\u5e94\u5b58\u5728\u91cf\u5316\u7684\u8bc1\u636e/Winning strategy corresponds to witnesses for existential quantification]\n    Results[\u5173\u952e\u7ed3\u679c/Results] --\x3e R1[\u4e3a\u2200\u2217\u2203\u2217 A-HLTL\u516c\u5f0f\u63d0\u4f9b\u65b9\u6cd5/Provides method for arbitrary \u2200\u2217\u2203\u2217 A-HLTL formulas]\n    Results --\x3e R2[\u8bc6\u522b\u5b8c\u5168\u6027\u7684\u7247\u6bb5/Identifies fragments for which the interpretation is complete]\n    Results --\x3e R3[\u539f\u578b\u5b9e\u73b0\u4e0e\u5b9e\u9a8c\u7ed3\u679c/Prototype implementation and experimental results]"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251230] A pumping-like lemma for languages over infinite alphabets"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [other], [automata theory], [infinite alphabets, pumping lemma, alternating finite-memory automata, semi-linearity, register automata]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Yoav Danieli"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," Technion \u2013 Israel Institute of Technology"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.23403",children:"https://arxiv.org/pdf/2512.23403"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Proves a novel pumping-like lemma for languages accepted by one-register alternating finite-memory automata. 2. Establishes that the set of word lengths in such languages is semi-linear as a corollary. 3. Contributes to the theoretical understanding of automata operating over infinite alphabets."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/90e852a1a56d9e1551a268ac13a7254da1d448f4cc3c291cf376a5878ecf409b_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/90e852a1a56d9e1551a268ac13a7254da1d448f4cc3c291cf376a5878ecf409b_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper addresses the study of languages over infinite alphabets. It proposes and proves a pumping-like lemma for languages accepted by a specific model of automata called one-register alternating finite-memory automata. As a main result, it concludes that the set of lengths of words in these languages is semi-linear."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TB\n    Root[A pumping-like lemma for languages over infinite alphabets] --\x3e Problem(\u6838\u5fc3\u95ee\u9898/Problem)\n    Root --\x3e Method(\u4e3b\u8981\u65b9\u6cd5/Method)\n    Root --\x3e Results(\u5173\u952e\u7ed3\u679c/Results)\n    Problem --\x3e P1[\u7814\u7a76\u65e0\u9650\u5b57\u6bcd\u8868\u4e0a\u7684\u8bed\u8a00/Study languages over infinite alphabets]\n    Method --\x3e M1[\u4e3a\u4e00\u5bc4\u5b58\u5668\u4ea4\u66ff\u6709\u9650\u5185\u5b58\u81ea\u52a8\u673a\u8bc1\u660e\u7c7b\u6cf5\u5f15\u7406/Prove pumping-like lemma for one-register alternating finite-memory automata]\n    Results --\x3e R1[\u8bed\u8a00\u957f\u5ea6\u96c6\u662f\u534a\u7ebf\u6027\u7684/Length set of such languages is semi-linear]"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251230] Beyond Correctness: Exposing LLM-generated Logical Flaws in Reasoning via Multi-step Automated Theorem Proving"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [nlp], [reasoning verification], [automated theorem proving, first-order logic, logical error detection, multi-step reasoning]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Xinyi Zheng, Ningke Li, Xiaokun Luan, Kailong Wang, Ling Shi, Meng Sun, Haoyu Wang"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," Huazhong University of Science and Technology, National University of Singapore, Peking University, Nanyang Technological University"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.23511",children:"https://arxiv.org/pdf/2512.23511"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Proposes MATP, a novel evaluation framework that uses Multi-step Automated Theorem Proving to verify LLM reasoning by translating it into First-Order Logic. 2. Provides a fine-grained classification of reasoning correctness, identifying hidden logical errors that are masked by fluent language. 3. Demonstrates superior performance over prompting-based baselines by over 42 percentage points and reveals disparities in logical coherence between different types of LLMs."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/7b9201185009c06f76b12e788768ccb6a8e2846d1d6ae7c9dcca57af7e332cc0_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/7b9201185009c06f76b12e788768ccb6a8e2846d1d6ae7c9dcca57af7e332cc0_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper introduces MATP, a framework that translates LLM-generated natural language reasoning into First-Order Logic and uses automated theorem provers to verify its step-by-step logical validity. It effectively exposes subtle logical flaws that existing methods miss. Evaluations show MATP significantly outperforms baselines and can enhance the trustworthiness of LLM reasoning for critical applications."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TB\n    A[Beyond Correctness: Exposing LLM-generated Logical Flaws<br>\u8d85\u8d8a\u6b63\u786e\u6027\uff1a\u901a\u8fc7\u591a\u6b65\u81ea\u52a8\u5b9a\u7406\u8bc1\u660e\u63ed\u793aLLM\u63a8\u7406\u4e2d\u7684\u903b\u8f91\u7f3a\u9677] --\x3e B(\u6838\u5fc3\u95ee\u9898/Problem)\n    A --\x3e C(\u4e3b\u8981\u65b9\u6cd5/Method)\n    A --\x3e D(\u5173\u952e\u7ed3\u679c/Results)\n    B --\x3e B1[LLM\u63a8\u7406\u5b58\u5728\u88ab\u6d41\u7545\u8bed\u8a00\u63a9\u76d6\u7684\u5fae\u5999\u903b\u8f91\u9519\u8bef<br>Subtle logical errors in LLM reasoning masked by fluent language]\n    C --\x3e C1[\u63d0\u51faMATP\u6846\u67b6\uff1a\u5c06\u81ea\u7136\u8bed\u8a00\u63a8\u7406\u8f6c\u5316\u4e3a\u4e00\u9636\u903b\u8f91<br>Propose MATP: Translates NL reasoning to FOL]\n    C --\x3e C2[\u4f7f\u7528\u81ea\u52a8\u5b9a\u7406\u8bc1\u660e\u5668\u8fdb\u884c\u591a\u6b65\u9a8c\u8bc1<br>Uses automated theorem provers for multi-step verification]\n    D --\x3e D1[\u5728\u63a8\u7406\u6b65\u9aa4\u9a8c\u8bc1\u4e0a\u8d85\u8d8a\u57fa\u7ebf42\u4e2a\u767e\u5206\u70b9<br>Surpasses baselines by over 42 percentage points]\n    D --\x3e D2[\u63ed\u793a\u63a8\u7406\u6a21\u578b\u6bd4\u901a\u7528\u6a21\u578b\u903b\u8f91\u66f4\u4e00\u81f4<br>Reveals reasoning models are more logically coherent]"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["[arXiv251230] ",(0,r.jsxs)(n.span,{className:"katex",children:[(0,r.jsx)(n.span,{className:"katex-mathml",children:(0,r.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(n.semantics,{children:[(0,r.jsx)(n.mrow,{children:(0,r.jsx)(n.mi,{children:"x"})}),(0,r.jsx)(n.annotation,{encoding:"application/x-tex",children:"x"})]})})}),(0,r.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,r.jsx)(n.span,{className:"mord mathnormal",children:"x"})]})})]})," Plays Pokemon, for Almost-Every ",(0,r.jsxs)(n.span,{className:"katex",children:[(0,r.jsx)(n.span,{className:"katex-mathml",children:(0,r.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(n.semantics,{children:[(0,r.jsx)(n.mrow,{children:(0,r.jsx)(n.mi,{children:"x"})}),(0,r.jsx)(n.annotation,{encoding:"application/x-tex",children:"x"})]})})}),(0,r.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,r.jsx)(n.span,{className:"mord mathnormal",children:"x"})]})})]})]})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [other], [automata theory], [disjunctive number, finite state game, automata theory, normal number, graph theory]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," C. Evans Hedges"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," None"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.23143",children:"https://arxiv.org/pdf/2512.23143"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Provides a formal proof that any disjunctive number will eventually win any finite state game., 2. Demonstrates the application of automata and graph theory to model deterministic computer games., 3. Serves as an expositional piece connecting a fun, popular context (\u03c0 playing Pok\xe9mon) to established mathematical results."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/dec4c5d33578d369070fe1724b7b1294356c3dc3138f2bd937c9f624d1243980_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/dec4c5d33578d369070fe1724b7b1294356c3dc3138f2bd937c9f624d1243980_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper models finite-state computer games as deterministic graphs and applies a known result from automata theory to prove that for any disjunctive number (which includes almost every real number), using its digits as button presses will eventually lead to winning the game. The conclusion is that while it's unknown if \u03c0 will win Pok\xe9mon, almost every real number will."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:'graph TB\n    Root("x Plays Pokemon, for Almost-Every x") --\x3e Problem("\u6838\u5fc3\u95ee\u9898/Problem: Will a number like \u03c0 eventually win a finite-state game like Pok\xe9mon?")\n    Root --\x3e Method("\u4e3b\u8981\u65b9\u6cd5/Method: Model game as a deterministic graph; apply automata theory results.")\n    Root --\x3e Results("\u5173\u952e\u7ed3\u679c/Results: Any disjunctive number (almost-every real number) will eventually win.")'}),"\n"]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);