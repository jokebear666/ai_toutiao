"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5892],{28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var s=i(96540);const r={},t=s.createContext(r);function a(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(t.Provider,{value:n},e.children)}},68422:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"daily/cs_LO/20251229-20260104","title":"20251229-20260104 (cs.LO)","description":"2025-12-29","source":"@site/docs/daily/cs_LO/20251229-20260104.md","sourceDirName":"daily/cs_LO","slug":"/daily/cslo/20251229-20260104","permalink":"/ai_toutiao/daily/cslo/20251229-20260104","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767583031000,"frontMatter":{"slug":"/daily/cslo/20251229-20260104"},"sidebar":"tutorialSidebar","previous":{"title":"20251222-20251228 (cs.LO)","permalink":"/ai_toutiao/daily/cslo/20251222-20251228"},"next":{"title":"20260105-20260111 (cs.LO)","permalink":"/ai_toutiao/daily/cslo/20260105-20260111"}}');var r=i(74848),t=i(28453);const a={slug:"/daily/cslo/20251229-20260104"},o="20251229-20260104 (cs.LO)",l={},c=[{value:"2025-12-29",id:"2025-12-29",level:2},{value:"2025-12-30",id:"2025-12-30",level:2},{value:"2026-01-01",id:"2026-01-01",level:2}];function d(e){const n={a:"a",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",mermaid:"mermaid",p:"p",span:"span",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"20251229-20260104-cslo",children:"20251229-20260104 (cs.LO)"})}),"\n",(0,r.jsx)(n.h2,{id:"2025-12-29",children:"2025-12-29"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251229] A Note on the NP-Hardness of PARTITION Via First-Order Projections"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [other], [computational complexity theory], [NP-hardness, first-order reductions, AC0 reductions, PARTITION problem, descriptive complexity]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Pa\xfal Risco Iturralde"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," Independent researcher"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.21448",children:"https://arxiv.org/pdf/2512.21448"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Demonstrates NP-hardness of the PARTITION problem via first-order projections, 2. Overcomes the obstacle of requiring large sums in the standard reduction by using descriptive complexity techniques, 3. Fills a gap in the literature regarding the hardness of PARTITION under restricted reductions like AC0."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/8b5d9f8d4b42755b482904c0cf03df329316dc9a10936a82fe27b6ce034a1e56_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/8b5d9f8d4b42755b482904c0cf03df329316dc9a10936a82fe27b6ce034a1e56_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This note addresses the open question of whether the PARTITION problem is NP-hard under restricted reductions like AC0. It modifies classic reductions from 3SAT to SUBSET-SUM to PARTITION, defining them using first-order logical formulas (first-order projections). The main conclusion is that PARTITION is indeed NP-hard via first-order projections, which implies hardness under polynomial-size AC0 reductions, thereby resolving the gap mentioned in prior work."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TB\n    A[\u8bba\u6587\u6807\u9898: A Note on the NP-Hardness of PARTITION Via First-Order Projections] --\x3e B(\u6838\u5fc3\u95ee\u9898/Problem)\n    A --\x3e C(\u4e3b\u8981\u65b9\u6cd5/Method)\n    A --\x3e D(\u5173\u952e\u7ed3\u679c/Results)\n    B --\x3e B1[PARTITION\u7684NP-hardness\u5728\u53d7\u9650\u5f52\u7ea6\u4e0b\u662f\u5426\u6210\u7acb?/Is PARTITION NP-hard under restricted reductions?]\n    C --\x3e C1[\u4f7f\u7528\u4e00\u9636\u903b\u8f91\u516c\u5f0f\u5b9a\u4e49\u5f52\u7ea6/Define reductions using first-order logic formulas]\n    C --\x3e C2[\u4fee\u6539\u7ecf\u5178\u5f52\u7ea6(3SAT\u5230SUBSET-SUM\u5230PARTITION)/Modify classic reductions (3SAT to SUBSET-SUM to PARTITION)]\n    D --\x3e D1[PARTITION\u5bf9\u4e00\u9636\u6295\u5f71\u662fNP-hard\u7684/PARTITION is NP-hard via first-order projections]\n    D --\x3e D2[\u6697\u793a\u5bf9\u591a\u9879\u5f0f\u5927\u5c0fAC0\u5f52\u7ea6\u4e5f\u662fNP-hard\u7684/Implies NP-hard under polynomial-size AC0 reductions]\n    D --\x3e D3[\u586b\u8865\u4e86\u6587\u732e\u4e2d\u7684\u7a7a\u767d/Fills a gap in the literature]"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251229] Quantitative Verification of Omega-regular Properties in Probabilistic Programming"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [other], [probabilistic programming and verification], [temporal posterior inference, omega-regular properties, stochastic barrier certificates, Rabin automata, quantitative verification]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Peixin Wang, Jianhao Bai, Min Zhang, C.-H. Luke Ong"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," East China Normal University, Nanyang Technological University"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.21596",children:"https://arxiv.org/pdf/2512.21596"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Introduces Temporal Posterior Inference (TPI), a new framework unifying probabilistic programming with temporal logic to compute posterior distributions over execution traces satisfying omega-regular properties. 2. Develops a novel method for computing rigorous upper and lower bounds on satisfaction probabilities by decomposing Rabin acceptance conditions and constructing sound stochastic barrier certificates. 3. Implements the approach in a prototype tool named TPInfer and demonstrates its effectiveness and efficiency on a suite of benchmarks."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/c111a01f9d5e96a85d9b5c62645dae0f5bb40053d723e34cb57dc7f31554dcda_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/c111a01f9d5e96a85d9b5c62645dae0f5bb40053d723e34cb57dc7f31554dcda_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper addresses the limitation of standard probabilistic program inference, which fails to capture temporal behavior, by proposing Temporal Posterior Inference (TPI). TPI computes posterior distributions over program traces that satisfy omega-regular temporal specifications, using a method based on stochastic barrier certificates to provide quantitative verification bounds. The approach is implemented in the TPInfer tool and shown to be effective for inference over rich temporal properties."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:'graph TB\n    Root("Quantitative Verification of Omega-regular Properties in Probabilistic Programming") --\x3e Problem("\u6838\u5fc3\u95ee\u9898/Problem")\n    Root --\x3e Method("\u4e3b\u8981\u65b9\u6cd5/Method")\n    Root --\x3e Results("\u5173\u952e\u7ed3\u679c/Results")\n    Problem --\x3e P1("\u6807\u51c6\u540e\u9a8c\u63a8\u65ad\u7684\u5c40\u9650/Limitation of Standard Posterior Inference")\n    P1 --\x3e P2("\u65e0\u6cd5\u6355\u6349\u7a0b\u5e8f\u6267\u884c\u7684\u65f6\u95f4\u6f14\u5316/Fails to capture temporal evolution")\n    Method --\x3e M1("\u63d0\u51fa\u65f6\u95f4\u540e\u9a8c\u63a8\u65ad\u6846\u67b6/Propose Temporal Posterior Inference (TPI)")\n    M1 --\x3e M2("\u7edf\u4e00\u6982\u7387\u7f16\u7a0b\u4e0e\u65f6\u5e8f\u903b\u8f91/Unifies Probabilistic Programming & Temporal Logic")\n    M2 --\x3e M3("\u57fa\u4e8e\u968f\u673a\u5c4f\u969c\u8bc1\u4e66\u7684\u5b9a\u91cf\u9a8c\u8bc1\u65b9\u6cd5/Quantitative Verification via Stochastic Barrier Certificates")\n    Results --\x3e R1("\u5b9e\u73b0\u539f\u578b\u5de5\u5177 TPInfer/Implement Prototype Tool TPInfer")\n    Results --\x3e R2("\u5728\u57fa\u51c6\u6d4b\u8bd5\u4e2d\u5c55\u793a\u6709\u6548\u6027\u4e0e\u6548\u7387/Demonstrates Effectiveness & Efficiency on Benchmarks")'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251229] First-Order Logic and Twin-Width for Some Geometric Graphs"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [other], [parameterized complexity], [twin-width, first-order logic, model checking, geometric graphs, FPT]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Colin Geniet, Gunwoo Kim, Lucas Meijer"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," Institute for Basic Science (IBS), KAIST, Utrecht University"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.21896",children:"https://arxiv.org/pdf/2512.21896"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Proved that delineation (the equivalence between tractable FO model checking and bounded twin-width) holds for intersection graphs of non-degenerate axis-parallel unit segments. 2. Showed that delineation fails for visibility graphs of 1.5D terrains. 3. Proved delineation for intersection graphs of circular arcs."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/813ec0f508efb48269593ee0f1c17c2ef7df235eda75353b1d1b0c5e93732fd3_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/813ec0f508efb48269593ee0f1c17c2ef7df235eda75353b1d1b0c5e93732fd3_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper investigates the relationship between tractable first-order (FO) logic model checking and the graph parameter twin-width for specific geometric graph classes. It answers open questions by proving this equivalence (delineation) holds for intersection graphs of axis-parallel unit segments and circular arcs, but fails for visibility graphs of 1.5D terrains. The work leverages the theory of twin-width for ordered graphs, exploiting natural vertex orderings in geometric representations."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TB\n    A[First-Order Logic and Twin-Width for Some Geometric Graphs] --\x3e B(\u6838\u5fc3\u95ee\u9898/Problem)\n    A --\x3e C(\u4e3b\u8981\u65b9\u6cd5/Method)\n    A --\x3e D(\u5173\u952e\u7ed3\u679c/Results)\n    B --\x3e B1(\u51e0\u4f55\u56fe\u7c7b\u7684FO\u6a21\u578b\u68c0\u67e5\u590d\u6742\u6027/FO Model Checking Complexity for Geometric Graph Classes)\n    C --\x3e C1(\u5229\u7528\u6709\u5e8f\u56fe\u7684\u53cc\u5bbd\u7406\u8bba/Using Twin-width Theory for Ordered Graphs)\n    D --\x3e D1(\u8bc1\u660e\u8f74\u5e73\u884c\u5355\u4f4d\u7ebf\u6bb5\u56fe\u4e0e\u5706\u5f27\u56fe\u5b58\u5728\u63cf\u7ed8/Prove Delineation for Axis-Parallel Unit Segment & Circular Arc Graphs)\n    D --\x3e D2(\u8bc1\u660e1.5D\u5730\u5f62\u53ef\u89c1\u6027\u56fe\u4e0d\u5b58\u5728\u63cf\u7ed8/Prove Delineation Fails for 1.5D Terrain Visibility Graphs)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251229] The Tensor-Plus Calculus"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [other], [categorical semantics], [graphical language, PROP, monoidal structure, semiring, semiadditive categories]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Kostia Chardonnet, Marc de Visme, Beno\xeet Valiron, Renaud Vilmart"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," Universit\xe9 Paris-Saclay, Universit\xe9 de Lorraine, CentraleSup\xe9lec"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.21965",children:"https://arxiv.org/pdf/2512.21965"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. A novel graphical language with implicit contextual distinction between multiplicative and additive monoidal structures, avoiding explicit annotations. 2. A universal categorical semantics for this language parameterized by a commutative semiring, applicable to non-deterministic, probabilistic, and quantum computation. 3. A sound and complete equational theory that captures semantic equivalence of diagrams."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/2ff122e66fc78c3e6d82c25811f0de1bdfef20eb6e522efbf05297bfacf2592d_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/2ff122e66fc78c3e6d82c25811f0de1bdfef20eb6e522efbf05297bfacf2592d_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," The paper proposes a new graphical calculus that implicitly combines multiplicative (pairing) and additive (branching) monoidal structures within a single, contextually-determined framework. It provides a universal categorical semantics for this language parameterized by a chosen commutative semiring, enabling the modeling of various computational paradigms. The work concludes by establishing a sound and complete equational theory for reasoning about diagram equivalence in this setting."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TB\n    A[The Tensor-Plus Calculus] --\x3e B[\u6838\u5fc3\u95ee\u9898/Problem: How to unify multiplicative and additive structures in a graphical language?]\n    A --\x3e C[\u4e3b\u8981\u65b9\u6cd5/Method: Colored PROP with implicit, contextual structure; semantics parameterized by a commutative semiring.]\n    A --\x3e D[\u5173\u952e\u7ed3\u679c/Results: Universal semantics; sound and complete equational theory for semiadditive categories.]"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251229] Random state comonads encode cellular automata evaluation"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [other], [formal methods & functional programming], [comonad, cellular automata, Haskell, category theory, stochastic]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Madalina I Sas, Julian H J Sutherland"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," Imperial College London"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.22067",children:"https://arxiv.org/pdf/2512.22067"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Introduces an accessible, practical category-theoretical model of Cellular Automata (CA) computation implemented in Haskell. 2. Proposes a novel instantiation of arrays as comonads with state and random generators, enabling the modeling of stochastic CA behavior. 3. Demonstrates the model's generality through case studies of classic 1D and 2D CAs and suggests extensions to N dimensions and arbitrary topologies."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/4dfe9b8ed8e24df98b4c296aebfc6cfdffc4132d68260502b6f113e9e9d43939_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/4dfe9b8ed8e24df98b4c296aebfc6cfdffc4132d68260502b6f113e9e9d43939_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper addresses the gap between abstract formalizations and practical implementations of Cellular Automata (CA). It proposes a functional programming model in Haskell using random state comonads to encode CA evaluation, which supports stochastic behavior and provides a direct mapping between simulation, rules, and categorical theory. The work demonstrates the approach with several classic CA models and suggests it can be generalized to arbitrary topologies."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:'graph TB\n    Root["Random state comonads encode cellular automata evaluation"] --\x3e Problem["\u6838\u5fc3\u95ee\u9898/Problem: Gap between abstract CA theory and practical, feature-rich implementations"]\n    Root --\x3e Method["\u4e3b\u8981\u65b9\u6cd5/Method: Haskell implementation using random state comonads"]\n    Root --\x3e Results["\u5173\u952e\u7ed3\u679c/Results: Accessible model supporting stochastic CA, demonstrated on classic models, extensible to N-D"]'}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"2025-12-30",children:"2025-12-30"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251230] Logic Sketch Prompting (LSP): A Deterministic and Interpretable Prompting Method"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [nlp], [prompt engineering], [Logic Sketch Prompting, deterministic prompting, interpretability, rule adherence, clinical decision support]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Satvik Tripathi"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," University of Pennsylvania"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.22258",children:"https://arxiv.org/pdf/2512.22258"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"code:"})," ",(0,r.jsx)(n.a,{href:"https://github.com/satviktri/LSP",children:"https://github.com/satviktri/LSP"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Proposes Logic Sketch Prompting (LSP), a lightweight prompting framework that introduces typed variables and deterministic condition evaluators for structured reasoning., 2. Incorporates a rule-based validator to produce traceable and repeatable outputs, enhancing auditability., 3. Demonstrates significant performance gains over standard prompting methods (zero-shot, chain-of-thought, concise) on pharmacologic logic-compliance tasks across multiple open-weight LLMs."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/3b5d49d54027e4f7e6b110a48568a0255a45010197e26e8bc344e0cd3e1785a9_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/3b5d49d54027e4f7e6b110a48568a0255a45010197e26e8bc344e0cd3e1785a9_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," The paper addresses the unreliability of LLMs on tasks requiring strict rule adherence and determinism. It proposes Logic Sketch Prompting (LSP), a framework using typed variables and rule-based validation to produce traceable outputs. Evaluations on clinical tasks show LSP significantly outperforms standard prompting methods in accuracy and F1 score, making it suitable for safety-critical systems."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TB\n    A[Logic Sketch Prompting (LSP)] --\x3e B[\u6838\u5fc3\u95ee\u9898/Problem: LLMs unreliable on tasks needing strict rules & determinism]\n    A --\x3e C[\u4e3b\u8981\u65b9\u6cd5/Method: Lightweight framework with typed variables, condition evaluators, rule validator]\n    A --\x3e D[\u5173\u952e\u7ed3\u679c/Results: Highest accuracy/F1 vs. baselines; suitable for clinical/safety-critical systems]"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251230] ReVEAL: GNN-Guided Reverse Engineering for Formal Verification of Optimized Multipliers"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [other], [formal verification, computer algebra], [reverse engineering, graph neural network, multiplier verification, algebraic circuit verification, SAT-based equivalence checking]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Chen Chen, Daniela Kaufmann, Chenhui Deng, Zhan Song, Hongce Zhang, Cunxi Yu"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," University of Maryland, College Park; TU Wien; NVIDIA; Hong Kong University of Science and Technology (Guangzhou)"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.22260",children:"https://arxiv.org/pdf/2512.22260"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Proposes ReVEAL, a graph-learning-based framework for reverse engineering optimized multiplier architectures to recover their word-level structure. 2. Leverages structural graph features and learning-driven inference to identify architectural patterns at scale, enabling robust handling of large, optimized circuits. 3. Integrates smoothly with existing verification flows and supports downstream algebraic proof strategies, showing improvements in scalability and accuracy over traditional rule-based approaches."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/8bdd1907cef6efb0b9b81d88b611f825942f30ef8a8674a9587cc4261e4774ef_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/8bdd1907cef6efb0b9b81d88b611f825942f30ef8a8674a9587cc4261e4774ef_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper introduces ReVEAL, a method that uses Graph Neural Networks (GNNs) to reverse engineer the architecture of optimized hardware multipliers. This recovered structure enables more effective formal verification using algebraic techniques. The approach demonstrates improved scalability and accuracy compared to traditional rule-based methods on diverse benchmarks."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TB\n    A[ReVEAL: GNN-Guided Reverse Engineering for Formal Verification of Optimized Multipliers] --\x3e B(\u6838\u5fc3\u95ee\u9898/Problem: \u4f18\u5316\u4e58\u6cd5\u5668\u5f62\u5f0f\u9a8c\u8bc1\u56f0\u96be/Challenges in formal verification of optimized multipliers)\n    A --\x3e C(\u4e3b\u8981\u65b9\u6cd5/Method: \u57fa\u4e8e\u56fe\u5b66\u4e60\u7684\u9006\u5411\u5de5\u7a0b/GNN-guided reverse engineering)\n    A --\x3e D(\u5173\u952e\u7ed3\u679c/Results: \u63d0\u5347\u53ef\u6269\u5c55\u6027\u4e0e\u51c6\u786e\u6027/Improved scalability and accuracy)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251230] Symbolic Specification and Reasoning for Quantum Data and Operations"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [other], [quantum programming languages & verification], [symbolic logic, formal verification, quantum computation, automated reasoning, SOL]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Mingsheng Ying"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," University of Technology Sydney"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.22383",children:"https://arxiv.org/pdf/2512.22383"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Proposes a novel logical framework called Symbolic Operator Logic (SOL) for symbolic specification of quantum data and operations., 2. Embeds classical first-order logic into SOL to enable reasoning about quantum properties modulo theories of classical data, leveraging existing classical verification tools., 3. Provides a conceptual foundation for formal verification and automated theorem proving of quantum computation in proof assistants like Lean and Coq."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/d170e9ed692953b589cb0ca609b55da71b661300061784405cc0fe9e73f4c680_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/d170e9ed692953b589cb0ca609b55da71b661300061784405cc0fe9e73f4c680_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper addresses the lack of a formal theory for symbolic reasoning in quantum computing by introducing a general logical framework called Symbolic Operator Logic (SOL). The core method embeds classical first-order logic into a language of formal operators for quantum specifications, enabling automated reasoning by reusing classical verification tools. The authors conclude that SOL provides a foundational framework for the formal verification of quantum algorithms and programs."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:'graph TB\n    Root["Symbolic Specification and Reasoning for Quantum Data and Operations"] --\x3e Problem\n    Root --\x3e Method\n    Root --\x3e Results\n    Problem["\u6838\u5fc3\u95ee\u9898/Problem<br>\u7f3a\u4e4f\u91cf\u5b50\u6570\u636e\u4e0e\u64cd\u4f5c\u7684\u5f62\u5f0f\u5316\u7b26\u53f7\u63a8\u7406\u7406\u8bba"] --\x3e P1["\u5bfc\u81f4\u7ed3\u679c/Consequence<br>\u9650\u5236\u91cf\u5b50\u7a0b\u5e8f\u81ea\u52a8\u9a8c\u8bc1\u7684\u5b9e\u7528\u6027"]\n    Method["\u4e3b\u8981\u65b9\u6cd5/Method<br>\u63d0\u51fa\u7b26\u53f7\u7b97\u5b50\u903b\u8f91(SOL)\u6846\u67b6"] --\x3e M1["\u5173\u952e\u6280\u672f/Key Technique<br>\u5c06\u7ecf\u5178\u4e00\u9636\u903b\u8f91\u5d4c\u5165\u5f62\u5f0f\u7b97\u5b50\u8bed\u8a00"]\n    Method --\x3e M2["\u4f18\u52bf/Advantage<br>\u57fa\u4e8e\u7ecf\u5178\u6570\u636e\u7406\u8bba(\u5982\u5e03\u5c14\u4ee3\u6570)\u8fdb\u884c\u63a8\u7406"]\n    Results["\u5173\u952e\u7ed3\u679c/Results<br>\u4e3a\u91cf\u5b50\u8ba1\u7b97\u5f62\u5f0f\u9a8c\u8bc1\u63d0\u4f9b\u6982\u5ff5\u57fa\u7840"] --\x3e R1["\u5e94\u7528\u524d\u666f/Application<br>\u7528\u4e8eLean, Coq\u7b49\u8bc1\u660e\u52a9\u624b"]'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251230] A Representation of Explicit Knowledge and Epistemic Indistinguishability in a Logic of Awareness"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [other], [epistemic logic], [awareness logic, explicit knowledge, logical omniscience, modal logic, completeness]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Yudai Kubono, Satoshi Tojo"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," Shizuoka University, Asia University"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.22477",children:"https://arxiv.org/pdf/2512.22477"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Proposes a refined definition of explicit knowledge in awareness logic that addresses undesirable derivations from Modus Ponens in implicit knowledge, 2. Introduces a new formal logic called Awareness-Based Indistinguishability Logic (AIL) with enhanced expressive power over the Fagin-Halpern logic, 3. Provides a sound and complete axiomatic system for AIL."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/ee03db160587ff877ac6134a739d58ab248a7f54166c46721902cd24c89d04bf_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/ee03db160587ff877ac6134a739d58ab248a7f54166c46721902cd24c89d04bf_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper addresses a flaw in the classic logic of awareness by Fagin and Halpern, where their definition of explicit knowledge can lead to undesirable conclusions. The authors propose a new logic called Awareness-Based Indistinguishability Logic (AIL), which refines the definition by linking indistinguishability of possible worlds to awareness. They prove AIL is more expressive than the prior logic and provide a sound and complete axiomatic system for it."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:'graph TB\n    A["A Representation of Explicit Knowledge and Epistemic Indistinguishability in a Logic of Awareness<br>\u8bba\u6587\u6807\u9898"] --\x3e B["\u6838\u5fc3\u95ee\u9898/Problem<br>Fagin-Halpern\u903b\u8f91\u4e2d\u663e\u5f0f\u77e5\u8bc6\u7684\u5b9a\u4e49\u53ef\u80fd\u5bfc\u81f4\u4e0d\u826f\u63a8\u8bba"]\n    A --\x3e C["\u4e3b\u8981\u65b9\u6cd5/Method<br>\u63d0\u51fa\u57fa\u4e8e\u610f\u8bc6\u7684\u4e0d\u53ef\u533a\u5206\u6027\u903b\u8f91(AIL)\uff0c\u7cbe\u786e\u5b9a\u4e49\u663e\u5f0f\u77e5\u8bc6"]\n    A --\x3e D["\u5173\u952e\u7ed3\u679c/Results<br>AIL\u66f4\u5177\u8868\u8fbe\u529b\uff0c\u53ef\u5d4c\u5165\u539f\u903b\u8f91\uff0c\u5e76\u5177\u5907\u53ef\u9760\u4e14\u5b8c\u5907\u7684\u516c\u7406\u7cfb\u7edf"]'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251230] Many-valued coalgebraic dynamic logics: Safety and strong completeness via reducibility"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [other], [formal methods], [coalgebraic modal logic, many-valued logic, dynamic logic, bisimulation safety, strong completeness]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Helle Hvid Hansen, Wolfgang Poiger"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," University of Groningen, Institute of Computer Science of the Czech Academy of Sciences"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.22851",children:"https://arxiv.org/pdf/2512.22851"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Proposes a coalgebraic framework for generalizing dynamic modal logics (like PDL and game logic) to many-valued settings where both propositions and semantic structures can take truth-degrees from an FLew-algebra. 2. Introduces the concept of reducible coalgebra operations and tests, proving that such operations are safe for bisimulation and behavioural equivalence. 3. Proves a general strong completeness theorem for the framework, leading to new strong completeness results for specific logics like 2-valued iteration-free PDL with many-valued accessibility relations and many-valued iteration-free game logic."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/3befe5f4bde38d3dda7c5a9f23902f5621b1316b62c6e3e2b1f3e208c172be1e_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/3befe5f4bde38d3dda7c5a9f23902f5621b1316b62c6e3e2b1f3e208c172be1e_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper presents a coalgebraic framework for generalizing dynamic modal logics to many-valued settings. It focuses on operations that are reducible, meaning modalities for composed actions can be reduced to compositions of simpler modalities, and proves these operations are safe for bisimulation and lead to strong completeness. The results yield new completeness theorems for specific many-valued versions of PDL and game logic."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TB\n    A[Many-valued Coalgebraic Dynamic Logics] --\x3e B[\u6838\u5fc3\u95ee\u9898/Problem: Generalizing dynamic logics (PDL, game logic) to many-valued settings]\n    A --\x3e C[\u4e3b\u8981\u65b9\u6cd5/Method: Coalgebraic framework with A-valued predicate liftings and reducible operations]\n    A --\x3e D[\u5173\u952e\u7ed3\u679c/Results: Reducible operations are safe for bisimulation; general strong completeness theorem proven]"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251230] PSPACE-Completeness of the Equational Theory of Relational Kleene Algebra with Graph Loop"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [other], [Formal Languages and Automata Theory], [Kleene algebra, graph loop, PSpace-completeness, loop-automata, equational theory]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Yoshiki Nakamura"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," Institute of Science Tokyo"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.22930",children:"https://arxiv.org/pdf/2512.22930"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Proved that the equational theory of relational Kleene algebra with the graph loop operator is PSpace-complete. 2. Introduced a novel automaton model called loop-automata to facilitate the complexity analysis. 3. Established a polynomial-time reduction from the equational theories to the language inclusion problem for 2-way alternating string automata."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/143a4383124a50a9271d22d401dedf3a296d859fe9ccfaf34be96747d60ca607_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/143a4383124a50a9271d22d401dedf3a296d859fe9ccfaf34be96747d60ca607_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper investigates the computational complexity of the equational theory for relational Kleene algebra extended with a graph loop operator. The authors introduce a new automaton model called loop-automata and use it to provide a polynomial-time reduction to a known automata problem. The main result is proving that this equational theory is PSpace-complete, a complexity that persists even with several other extensions."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TB\n    Root[PSPACE-Completeness of the Equational Theory of Relational Kleene Algebra with Graph Loop] --\x3e Problem\n    Root --\x3e Method\n    Root --\x3e Results\n    Problem[\u6838\u5fc3\u95ee\u9898/Problem: Which extensions of Relational Kleene Algebra (RKA) keep PSpace-complete equational theory?]\n    Method[\u4e3b\u8981\u65b9\u6cd5/Method: Introduce loop-automata; Reduce to 2-way alternating automata inclusion problem]\n    Results[\u5173\u952e\u7ed3\u679c/Results: Equational theory of loop-RKA is PSpace-complete; Result holds with top, tests, converse, nominals]"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251230] Hypergraph Semantics for Doxastic Logics"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [other], [modal logic], [directed hypergraphs, doxastic logic, simplicial models, canonical models, Kripke models]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Hans van Ditmarsch, Djanira Gomes, David Lehnherr, Valentin M\xfcller, Thomas Studer"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," CNRS, IRIT, University of Toulouse, University of Bern"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.23088",children:"https://arxiv.org/pdf/2512.23088"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Introduces a new semantics for logics of belief based on directed hypergraphs, extending beyond the knowledge-only representation of simplicial models. 2. Provides complete axiomatizations for systems of both consistent belief and merely introspective belief, proven via the construction of canonical hypergraph models. 3. Presents direct conversion methods between traditional doxastic Kripke models and the new directed hypergraph models."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/9148e7fe21d36571fcaa8501e6f6f8e914b61b99c9fad3c304b84d0731e14147_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/9148e7fe21d36571fcaa8501e6f6f8e914b61b99c9fad3c304b84d0731e14147_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper addresses the limitation of simplicial models, which can represent knowledge but not beliefs in distributed systems. It proposes a new semantics for belief logics using directed hypergraphs, which retain the structural benefits of simplicial models while accommodating agent beliefs. The work establishes complete axiomatizations for belief systems and shows how the new models relate to standard Kripke models."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:'graph TB\n    Root("Hypergraph Semantics for Doxastic Logics<br/>\u8d85\u56fe\u8bed\u4e49\u7528\u4e8e\u4fe1\u5ff5\u903b\u8f91") --\x3e Problem("\u6838\u5fc3\u95ee\u9898/Problem")\n    Root --\x3e Method("\u4e3b\u8981\u65b9\u6cd5/Method")\n    Root --\x3e Results("\u5173\u952e\u7ed3\u679c/Results")\n    Problem --\x3e P1("Simplicial models cannot represent beliefs<br/>\u5355\u7eaf\u590d\u5f62\u6a21\u578b\u65e0\u6cd5\u8868\u793a\u4fe1\u5ff5")\n    Method --\x3e M1("New semantics using directed hypergraphs<br/>\u4f7f\u7528\u6709\u5411\u8d85\u56fe\u7684\u65b0\u8bed\u4e49")\n    Results --\x3e R1("Complete axiomatizations for belief systems<br/>\u4fe1\u5ff5\u7cfb\u7edf\u7684\u5b8c\u5907\u516c\u7406\u5316")\n    Results --\x3e R2("Conversions to/from Kripke models<br/>\u4e0e\u514b\u91cc\u666e\u514b\u6a21\u578b\u7684\u76f8\u4e92\u8f6c\u6362")'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["[arXiv251230] On Conformant Planning and Model-Checking of ",(0,r.jsx)(n.span,{className:"katex-error",title:"ParseError: KaTeX parse error: Double superscript at position 3: ^*^\u0332*",style:{color:"#cc0000"},children:"^*^*"})," Hyperproperties"]})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [other], [formal methods], [conformant planning, hyperproperties, model-checking, HyperLTL, \u2203\u2217\u2200\u2217]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Raven Beutner, Bernd Finkbeiner"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," CISPA Helmholtz Center for Information Security"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.23324",children:"https://arxiv.org/pdf/2512.23324"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Establishes a formal connection between conformant planning and model-checking of \u2203\u2217\u2200\u2217 hyperproperties, showing they share the same computational core. 2. Provides an efficient, sound, and complete reduction from a hyperproperty model-checking instance to a conformant planning instance. 3. Demonstrates that every conformant planning problem is itself a hyperproperty model-checking task, establishing the converse direction."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/47343ca7bc4bf16389257261dd21e0c1fa42c0f512178576ff4ba501df841e8b_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/47343ca7bc4bf16389257261dd21e0c1fa42c0f512178576ff4ba501df841e8b_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper identifies and formalizes a deep connection between two seemingly unrelated problems: conformant planning (finding a robust sequential plan under uncertainty) and model-checking of \u2203\u2217\u2200\u2217 hyperproperties (verifying system properties that relate multiple execution traces). The authors provide efficient, sound, and complete translations between instances of these two problems, showing they are essentially two sides of the same computational coin. This foundational link aims to enable cross-pollination of solution techniques between the planning and verification communities."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TB\n    A[On Conformant Planning and Model-Checking of \u2203\u2217\u2200\u2217 Hyperproperties] --\x3e B(\u6838\u5fc3\u95ee\u9898/Problem)\n    A --\x3e C(\u4e3b\u8981\u65b9\u6cd5/Method)\n    A --\x3e D(\u5173\u952e\u7ed3\u679c/Results)\n    B --\x3e B1[\u8fde\u63a5\u4e24\u4e2a\u770b\u4f3c\u65e0\u5173\u7684\u95ee\u9898 / Linking two seemingly unrelated problems]\n    B1 --\x3e B2[Conformant Planning / \u4e00\u81f4\u6027\u89c4\u5212]\n    B1 --\x3e B3[Hyperproperty Model-Checking / \u8d85\u5c5e\u6027\u6a21\u578b\u68c0\u6d4b]\n    C --\x3e C1[\u6784\u5efa\u53cc\u5411\u9ad8\u6548\u89c4\u7ea6 / Constructing bidirectional efficient reductions]\n    D --\x3e D1[\u8bc1\u660e\u89c4\u7ea6\u7684\u53ef\u9760\u6027\u4e0e\u5b8c\u5907\u6027 / Proving reductions are sound and complete]\n    D --\x3e D2[\u786e\u7acb\u95ee\u9898\u7684\u7b49\u4ef7\u6027 / Establishing the equivalence of the problems]"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251230] Checking Satisfiability of Hyperproperties using First-Order Logic"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [sec], [formal verification], [hyperproperties, HyperLTL, satisfiability checking, first-order logic, FOLHyper]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Raven Beutner, Bernd Finkbeiner"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," CISPA Helmholtz Center for Information Security"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.23332",children:"https://arxiv.org/pdf/2512.23332"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Introduces FOLHyper, a tool for automatically checking the satisfiability of hyperproperties specified in HyperLTL. 2. Reduces the HyperLTL satisfiability problem to an equisatisfiable first-order logic formula, enabling the use of standard FOL solvers. 3. Extends applicability beyond the decidable \u2203",(0,r.jsx)(n.em,{children:"\u2200"})," fragment of HyperLTL and is shown to be particularly effective at proving unsatisfiability, complementing existing bounded methods."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/1df9c7eeb320b67a7ee7c2bfb2c3c7df8d5c7c6cfd6201d5246d2ea403911999_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/1df9c7eeb320b67a7ee7c2bfb2c3c7df8d5c7c6cfd6201d5246d2ea403911999_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper addresses the problem of checking the satisfiability of hyperproperties, which are crucial for security and information-flow specifications. It proposes FOLHyper, a tool that translates HyperLTL formulas into equisatisfiable first-order logic formulas, allowing the use of FOL solvers for analysis. The method extends beyond known decidable fragments and is shown to be effective, especially for proving unsatisfiability."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TB\n    A[Checking Satisfiability of Hyperproperties using First-Order Logic] --\x3e B[\u6838\u5fc3\u95ee\u9898/Problem: \u8d85\u5c5e\u6027\u53ef\u6ee1\u8db3\u6027\u68c0\u67e5/Hyperproperty Satisfiability Checking]\n    A --\x3e C[\u4e3b\u8981\u65b9\u6cd5/Method: \u5c06HyperLTL\u7ea6\u7b80\u4e3a\u4e00\u9636\u903b\u8f91\u516c\u5f0f/Reduce HyperLTL to FOL]\n    A --\x3e D[\u5173\u952e\u7ed3\u679c/Results: FOLHyper\u5de5\u5177\uff0c\u6709\u6548\u8bc1\u660e\u4e0d\u53ef\u6ee1\u8db3\u6027/FOLHyper Tool, Effective for Unsatisfiability]"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251230] Verifying Asynchronous Hyperproperties in Reactive Systems"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [sec], [formal verification], [asynchronous hyperproperties, HyperLTL, model checking, game semantics, observational determinism]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Raven Beutner, Bernd Finkbeiner"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," CISPA Helmholtz Center for Information Security"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.23344",children:"https://arxiv.org/pdf/2512.23344"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Proposes a novel game-based approach for verifying arbitrary \u2200\u2217\u2203\u2217 formulas in Asynchronous HyperLTL (A-HLTL) in reactive systems. 2. Interprets verification as a game between a verifier and refuter, where a winning strategy provides witnesses for traces and asynchronous alignments for stutterings. 3. Identifies fragments for which the game-based interpretation is complete, providing a finite-state decision procedure, and contributes a prototype implementation with encouraging experimental results."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/0e321908ac7277c8c91e3b8e509efae3be66dbe7c391e613f19a6ca343db4f16_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/0e321908ac7277c8c91e3b8e509efae3be66dbe7c391e613f19a6ca343db4f16_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper addresses the challenge of model-checking asynchronous hyperproperties in reactive systems, which require comparing execution traces across different timesteps. It proposes a novel game-based verification method for a logic called Asynchronous HyperLTL (A-HLTL), interpreting the problem as a two-player game to find suitable trace stutterings. The approach provides a decision procedure for certain formula fragments and is supported by a prototype implementation."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TB\n    Root[Verifying Asynchronous Hyperproperties in Reactive Systems] --\x3e Problem\n    Root --\x3e Method\n    Root --\x3e Results\n    Problem[\u6838\u5fc3\u95ee\u9898/Problem] --\x3e P1[\u540c\u6b65HyperLTL\u65e0\u6cd5\u8868\u8fbe\u5f02\u6b65\u8d85\u5c5e\u6027/Synchronous HyperLTL cannot express asynchronous hyperproperties]\n    Problem --\x3e P2[\u73b0\u6709\u65b9\u6cd5\u9650\u5236\u4e8e\u53d7\u9650\u7247\u6bb5\u6216\u7ec8\u6b62\u7cfb\u7edf/Existing methods limited to restricted fragments or terminating systems]\n    Method[\u4e3b\u8981\u65b9\u6cd5/Method] --\x3e M1[\u63d0\u51fa\u57fa\u4e8e\u6e38\u620f\u7684\u9a8c\u8bc1\u65b9\u6cd5/Propose a game-based verification approach]\n    Method --\x3e M2[\u9a8c\u8bc1\u8005\u4e0e\u53cd\u9a73\u8005\u7684\u53cc\u4eba\u6e38\u620f/Two-player game between verifier and refuter]\n    Method --\x3e M3[\u83b7\u80dc\u7b56\u7565\u5bf9\u5e94\u5b58\u5728\u91cf\u5316\u7684\u8bc1\u636e/Winning strategy corresponds to witnesses for existential quantification]\n    Results[\u5173\u952e\u7ed3\u679c/Results] --\x3e R1[\u4e3a\u2200\u2217\u2203\u2217 A-HLTL\u516c\u5f0f\u63d0\u4f9b\u65b9\u6cd5/Provides method for arbitrary \u2200\u2217\u2203\u2217 A-HLTL formulas]\n    Results --\x3e R2[\u8bc6\u522b\u5b8c\u5168\u6027\u7684\u7247\u6bb5/Identifies fragments for which the interpretation is complete]\n    Results --\x3e R3[\u539f\u578b\u5b9e\u73b0\u4e0e\u5b9e\u9a8c\u7ed3\u679c/Prototype implementation and experimental results]"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251230] Modelling of logical systems by means of their fragments"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [other], [computational logic], [superintuitionistic logics, modal logics, complexity reduction, Kripke incompleteness, predicate calculi]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Mikhail Rybakov"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," Moscow Institute of Physics and Technology (MIPT)"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.23509",children:"https://arxiv.org/pdf/2512.23509"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Proved polynomial-time reducibility of propositional logics to their fragments with at most two variables. 2. Established reducibility of predicate logics to fragments with limited predicate letters and individual variables, with conditions and counterexamples. 3. Provided new complexity bounds, Kripke-incompleteness results, and analogues of Church and Trakhtenbrot theorems for quasiary predicate logic."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/6250c5fb6676c8f8ac8f9a2e9bc581ee4e2c8b46c6236e4948549173497931aa_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/6250c5fb6676c8f8ac8f9a2e9bc581ee4e2c8b46c6236e4948549173497931aa_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This work investigates the algorithmic complexity of non-classical logics. It demonstrates that many propositional and predicate logics can be reduced to simpler, smaller fragments, establishing conditions for such reductions and providing counterexamples. The results include new complexity bounds and fundamental incompleteness theorems for these logical systems."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TB\n    A[Modelling of logical systems by means of their fragments] --\x3e B(\u6838\u5fc3\u95ee\u9898/Problem: Algorithmic complexity of non-classical logics)\n    A --\x3e C(\u4e3b\u8981\u65b9\u6cd5/Method: Reduction to simpler fragments)\n    A --\x3e D(\u5173\u952e\u7ed3\u679c/Results: Complexity bounds, reducibility conditions, incompleteness theorems)"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"2026-01-01",children:"2026-01-01"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv260101] Biochemical Computing Mode for Sequential Logic"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [other], [unconventional computing, biochemical computing], [sequential logic, biochemical computing, enzymatic reactions, logic gate, sequential mapping]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Han Huang, Chengzhi Ma, Yuxin Zhao, Qingyao Wang, Xinglong Xiao, Xiulin Shu, Zhifeng Hao"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," South China University of Technology"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.23734",children:"https://arxiv.org/pdf/2512.23734"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"}),' 1. Demonstrates and highlights the concept of "sequential mapping" as a crucial necessary condition for realizing sequential logic circuits in general-purpose computers. 2. Proposes a novel biochemical computing mode using enzyme-controlled reactions to design a logic gate model composed of small molecules. 3. Mathematically proves that the proposed biochemical computing mode satisfies sequential mapping and, combined with storage characteristics, can realize sequential logic circuits.']}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/8a445dc0ec7c178dcff0eacecd2ca96419424f5499d1a975b953630aaa1254da_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/8a445dc0ec7c178dcff0eacecd2ca96419424f5499d1a975b953630aaa1254da_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," The paper addresses the challenge of implementing sequential logic in next-generation computing paradigms. It proposes a biochemical computing mode using enzyme-driven molecular logic gates and mathematically proves it satisfies the sequential mapping property, enabling sequential logic circuits. This work provides a theoretical foundation for developing general-purpose biochemical computers."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TB\n    A[Biochemical Computing Mode for Sequential Logic] --\x3e B(\u6838\u5fc3\u95ee\u9898/Problem)\n    A --\x3e C(\u4e3b\u8981\u65b9\u6cd5/Method)\n    A --\x3e D(\u5173\u952e\u7ed3\u679c/Results)\n    B --\x3e B1[Sequential logic implementation is overlooked in unconventional computing/\u975e\u5e38\u89c4\u8ba1\u7b97\u4e2d\u65f6\u5e8f\u903b\u8f91\u7684\u5b9e\u73b0\u88ab\u5ffd\u89c6]\n    C --\x3e C1[Design enzyme-driven molecular logic gates/\u8bbe\u8ba1\u9176\u9a71\u52a8\u7684\u5206\u5b50\u903b\u8f91\u95e8]\n    C --\x3e C2[Mathematical analysis of input-output properties/\u8f93\u5165\u8f93\u51fa\u7279\u6027\u7684\u6570\u5b66\u5206\u6790]\n    D --\x3e D1[Proves biochemical mode satisfies sequential mapping/\u8bc1\u660e\u751f\u5316\u6a21\u5f0f\u6ee1\u8db3\u987a\u5e8f\u6620\u5c04]\n    D --\x3e D2[Enables sequential logic circuits/\u80fd\u591f\u5b9e\u73b0\u65f6\u5e8f\u903b\u8f91\u7535\u8def]\n    D --\x3e D3[Foundation for general-purpose biochemical computers/\u4e3a\u901a\u7528\u751f\u5316\u8ba1\u7b97\u673a\u5960\u5b9a\u57fa\u7840]"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv260101] Enforcing Temporal Constraints for LLM Agents"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [mlsys], [agent system], [temporal constraints, SMT solving, constrained generation, formal verification, LLM agents]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Adharsh Kamath, Sishen Zhang, Calvin Xu, Shubham Ugare, Gagandeep Singh, Sasa Misailovic"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," University of Illinois at Urbana-Champaign, Meta"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.23738",children:"https://arxiv.org/pdf/2512.23738"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"code:"})," ",(0,r.jsx)(n.a,{href:"https://github.com/structuredllm/agent-c",children:"https://github.com/structuredllm/agent-c"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. A novel framework (Agent-C) providing runtime guarantees for LLM agents to adhere to formal temporal safety properties., 2. A domain-specific language for expressing temporal properties, which are translated to first-order logic and verified via SMT solving during token generation., 3. Demonstration of perfect safety (100% conformance) and improved task utility across real-world applications and multiple LLMs, outperforming state-of-the-art guardrails."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/3a978adfab8b202d7b971f6b65f8d005235baabb93f5540985ad131638c67354_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/3a978adfab8b202d7b971f6b65f8d005235baabb93f5540985ad131638c67354_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," The paper addresses the problem of LLM agents violating temporal safety policies, such as accessing data before authentication. It proposes Agent-C, a framework that uses a domain-specific language, formal logic translation, and SMT solving to enforce constraints during token generation, ensuring compliant actions. The evaluation shows Agent-C achieves 100% safety conformance and improves task utility compared to existing methods."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TB\n    A[Enforcing Temporal Constraints for LLM Agents] --\x3e B[\u6838\u5fc3\u95ee\u9898/Problem]\n    A --\x3e C[\u4e3b\u8981\u65b9\u6cd5/Method]\n    A --\x3e D[\u5173\u952e\u7ed3\u679c/Results]\n    B --\x3e B1[\u73b0\u6709\u62a4\u680f\u65e0\u6cd5\u4fdd\u8bc1\u65f6\u95f4\u5b89\u5168\u7b56\u7565/Existing guardrails fail to enforce temporal safety policies]\n    C --\x3e C1[\u63d0\u51faAgent-C\u6846\u67b6/Propose Agent-C framework]\n    C1 --\x3e C2[\u4f7f\u7528DSL\u548cSMT\u6c42\u89e3\u8fdb\u884c\u8fd0\u884c\u65f6\u9a8c\u8bc1/Use DSL & SMT solving for runtime verification]\n    C2 --\x3e C3[\u91c7\u7528\u7ea6\u675f\u751f\u6210\u786e\u4fdd\u5408\u89c4/Achieve compliance via constrained generation]\n    D --\x3e D1[100%\u5b89\u5168\u6027\uff0c0%\u5371\u5bb3/100% safety, 0% harm]\n    D --\x3e D2[\u5728\u771f\u5b9e\u5e94\u7528\u4e2d\u63d0\u9ad8\u4efb\u52a1\u6548\u7528/Improve task utility in real-world applications]"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv260101] A precise proof of the n-variable Bekic principle"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [other], [formal verification], [Beki\u010d principle, fixed point, lexicographic order, complete lattice, monotone function]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Jun Xu"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," None (No affiliation or email domain provided in the given content)"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.24038",children:"https://arxiv.org/pdf/2512.24038"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Provides a rigorous, inductive proof of the n-variable Beki\u010d principle for n>3, which has been missing from the literature. 2. Formalizes the principle by expressing a vectorial fixpoint as nested fixpoints organized according to lexicographic order, making it suitable for theorem provers. 3. Clarifies the structure of the generalization by showing the correspondence between the nesting structure and strings over an alphabet without repetition."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/4db85492f5b6e4642bc422cde756fe37f08a0abcae8a05883ab79043a073280a_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/4db85492f5b6e4642bc422cde756fe37f08a0abcae8a05883ab79043a073280a_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper addresses the lack of a formal proof for the n-variable generalization of the Beki\u010d principle, which decomposes a vectorial fixed point into nested fixed points. The authors provide a rigorous inductive proof that structures the fixpoints according to lexicographic order, making the result suitable for formal verification in theorem provers."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:'graph TB\n    Root["A precise proof of the n-variable Bekic principle<br/>n\u53d8\u91cfBekic\u539f\u7406\u7684\u7cbe\u786e\u8bc1\u660e"] --\x3e Problem\n    Root --\x3e Method\n    Root --\x3e Results\n    Problem["\u6838\u5fc3\u95ee\u9898/Problem<br/>Missing formal proof for n-ary Beki\u010d principle (n>3)<br/>\u7f3a\u5c11n\u5143Beki\u010d\u539f\u7406\uff08n>3\uff09\u7684\u5f62\u5f0f\u5316\u8bc1\u660e"] --\x3e P1["\u76ee\u6807/Goal<br/>Generalize the 2-variable case to n variables<br/>\u5c06\u4e8c\u5143\u60c5\u51b5\u63a8\u5e7f\u5230n\u5143"]\n    Method["\u4e3b\u8981\u65b9\u6cd5/Method<br/>Inductive proof based on lexicographic order<br/>\u57fa\u4e8e\u5b57\u5178\u5e8f\u7684\u5f52\u7eb3\u8bc1\u660e"] --\x3e M1["\u6280\u672f/Technique<br/>Organize fixpoints into a tree structure<br/>\u5c06\u4e0d\u52a8\u70b9\u7ec4\u7ec7\u4e3a\u6811\u7ed3\u6784"]\n    Results["\u5173\u952e\u7ed3\u679c/Results<br/>Precise statement and proof of the n-variable principle<br/>n\u53d8\u91cf\u539f\u7406\u7684\u7cbe\u786e\u9648\u8ff0\u4e0e\u8bc1\u660e"] --\x3e R1["\u5e94\u7528/Application<br/>Suitable for formalization in theorem provers<br/>\u9002\u7528\u4e8e\u5b9a\u7406\u8bc1\u660e\u5668\u4e2d\u7684\u5f62\u5f0f\u5316"]'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv260101] Proof-Carrying PWL Verification for ReLU Networks: Convex-Hull Semantics, Exact / Encodings, and Symbolic Certificate Checking"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [ai], [neural network verification], [ReLU verification, convex hull, LP duality, Farkas lemma, proof-carrying verification]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Chandrasekhar Gokavarapu"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," Government College (Autonomous), Rajahmundry"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.24339",children:"https://arxiv.org/pdf/2512.24339"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Formalizes ReLU networks as unions of polyhedra indexed by activation patterns. 2. Presents exact SMT/MILP encodings and the canonical convex-hull relaxation for bounded ReLUs. 3. Introduces a certificate calculus that emits explicit algebraic witnesses (like LP dual multipliers) for verification steps, enabling independent, exact symbolic checking."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/94c44dc227a06c8817ca647176e90fb57664e45f650fe73d475d3a56b323d3d0_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/94c44dc227a06c8817ca647176e90fb57664e45f650fe73d475d3a56b323d3d0_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," The paper addresses the need for checkable evidence in the formal verification of ReLU neural networks. It proposes a proof-carrying verification core that generates symbolic certificates (e.g., LP dual multipliers) for each step of the verification process, which can be independently verified using exact arithmetic. This approach transforms neural verification into a pipeline where the final safety claim is backed by a machine-checkable, compositional proof artifact."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TB\n    A[Proof-Carrying PWL Verification for ReLU Networks] --\x3e B\n    A --\x3e C\n    A --\x3e D\n    B[\u6838\u5fc3\u95ee\u9898/Problem: Safety claims need checkable evidence, not just unsat verdicts]\n    C[\u4e3b\u8981\u65b9\u6cd5/Method: Certificate calculus emitting symbolic witnesses (LP duals, Farkas certificates)]\n    D[\u5173\u952e\u7ed3\u679c/Results: Symbolic checker, compositional proof artifact for universal safety]"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv260101] Open Horn Type Theory"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [other], [type theory], [dependent type theory, homotopy type theory, simplicial sets, coherence, obstruction]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Iman Poernomo"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," ICRA Press"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.24498",children:"https://arxiv.org/pdf/2512.24498"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Introduces Open Horn Type Theory (OHTT), a novel extension of dependent type theory with primitive coherence and gap judgments, 2. Develops the semantics of OHTT using ruptured simplicial sets and ruptured Kan complexes, 3. Demonstrates three classes of applications for OHTT's gap witnesses: topological, semantic, and logical obstructions"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/11be216c3251a0f9974241ff50b07a4182d33ebbf2733b1215675aa40cf6f09a_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/11be216c3251a0f9974241ff50b07a4182d33ebbf2733b1215675aa40cf6f09a_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"}),' The paper introduces Open Horn Type Theory (OHTT), a new dependent type theory that adds primitive "coherence" and "gap" judgments to model obstructions that standard Homotopy Type Theory cannot express. It provides a semantics based on ruptured simplicial sets and shows that OHTT can capture topological, semantic, and logical obstructions as positive structural witnesses.']}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TB\n    Root[Open Horn Type Theory] --\x3e Problem\n    Root --\x3e Method\n    Root --\x3e Results\n    Problem[\u6838\u5fc3\u95ee\u9898/Problem] --\x3e P1[HoTT\u65e0\u6cd5\u8868\u8fbe\u67d0\u4e9b\u963b\u788d/HoTT cannot express certain obstructions]\n    Method[\u4e3b\u8981\u65b9\u6cd5/Method] --\x3e M1[\u5f15\u5165OHTT\uff0c\u6269\u5c55\u4f9d\u8d56\u7c7b\u578b\u8bba/Introduce OHTT, extending dependent type theory]\n    Method --\x3e M2[\u539f\u59cb\u5224\u65ad\uff1a\u4e00\u81f4\u6027\u3001\u95f4\u9699/Primitive judgments: coherence, gap]\n    Method --\x3e M3[\u8bed\u4e49\uff1a\u7834\u88c2\u5355\u7eaf\u96c6/Semantics: ruptured simplicial sets]\n    Results[\u5173\u952e\u7ed3\u679c/Results] --\x3e R1[\u6355\u83b7\u4f20\u8f93\u963b\u788d/Captures transport obstructions]\n    Results --\x3e R2[\u5d4c\u5165HoTT\u4e3a\u4e00\u81f4\u7247\u6bb5/Embeds HoTT as coherent fragment]\n    Results --\x3e R3[\u53d1\u5c55\u4e09\u7c7b\u963b\u788d\u5e94\u7528/Develops three classes of obstruction applications]"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv260101] A Tale of 1001 LoC: Potential Runtime Error-Guided Specification Synthesis for Verifying Large-Scale Programs"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [se], [formal verification], [specification synthesis, deductive verification, static analysis, runtime error, large language models]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Zhongyi Wang, Tengjie Lin, Mingshuai Chen, Haokun Li, Mingqi Yang, Xiao Yi, Shengchao Qin, Yixing Luo, Xiaofeng Li, Bin Gu, Liqiang Lu, Jianwei Yin"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," Zhejiang University, Peking University, The Chinese University of Hong Kong, Xidian University, Beijing Institute of Control Engineering"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.24594",children:"https://arxiv.org/pdf/2512.24594"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. A modular framework (Preguss) that synergizes static analysis and deductive verification for specification generation. 2. A potential runtime error-guided method to construct and prioritize verification units, enabling divide-and-conquer verification. 3. An LLM-aided approach for synthesizing interprocedural specifications at the unit level, overcoming long-context reasoning limitations."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/59ea3656fd77af57b3d01dd85b22b70b81b2bc6a890ef83bd4e98afe3dad61df_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/59ea3656fd77af57b3d01dd85b22b70b81b2bc6a890ef83bd4e98afe3dad61df_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper presents Preguss, a framework that combines static analysis and LLMs to automate the generation of formal specifications for verifying large-scale programs. It uses potential runtime errors to guide the creation of verification units and then synthesizes specifications for each unit, significantly reducing human effort. The method enables highly automated verification for programs over 1000 lines of code, reducing human verification effort by 80.6% to 88.9%."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:'graph TB\n    Root["A Tale of 1001 LoC: Potential Runtime Error-Guided Specification Synthesis for Verifying Large-Scale Programs"]\n    Root --\x3e Problem["\u6838\u5fc3\u95ee\u9898/Problem<br>LLMs struggle with automated verification of large-scale programs due to long-context reasoning and complex specification inference."]\n    Root --\x3e Method["\u4e3b\u8981\u65b9\u6cd5/Method<br>Preguss framework synergizes static analysis and deductive verification via error-guided unit construction and LLM-aided specification synthesis."]\n    Root --\x3e Results["\u5173\u952e\u7ed3\u679c/Results<br>Enables verification of 1000+ LoC programs with 80.6%~88.9% reduction in human effort, outperforming SOTA."]'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv260101] LeanCat: A Benchmark Suite for Formal Category Theory in Lean (Part I: 1-Categories)"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [ai], [theorem proving], [formal verification, category theory, benchmark, Lean, large language models]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Rongge Xu, Hui Dai, Yiming Fu, Jiedong Jiang, Tianjiao Nie, Hongwei Wang, Junkai Wang, Holiverse Yang, Jiatong Yang, Zhi-Hao Zhang"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," Tsinghua University, Southern University of Science and Technology, Westlake University, Xi'an Jiaotong-Liverpool University, The Chinese University of Hong Kong, Yanqi Lake Beijing Institute of Mathematical Sciences and Applications (BIMSA)"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.24796",children:"https://arxiv.org/pdf/2512.24796"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"code:"})," ",(0,r.jsx)(n.a,{href:"https://github.com/sciencraft/LeanCat",children:"https://github.com/sciencraft/LeanCat"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Introduces LeanCat, a benchmark for formal category theory in Lean, designed to stress-test abstraction and library-mediated reasoning. 2. Presents a curated dataset of 100 tasks with topic families and difficulty tiers, created via an LLM-assisted human grading process. 3. Demonstrates the benchmark's utility by evaluating models and the LeanBridge method, showing current AI capabilities and providing a checkpoint for tracking progress."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/4bb17bb33fa46697baca7f3b3a6262916453dd0a4bf5f92ff26cebdd7d681ffe_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/4bb17bb33fa46697baca7f3b3a6262916453dd0a4bf5f92ff26cebdd7d681ffe_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," The paper introduces LeanCat, a benchmark for formalizing category theory in Lean to better evaluate AI's ability for abstract, library-based reasoning in mathematics. It presents a curated set of 100 tasks and evaluates models, finding low success rates, especially on harder problems, while showing that retrieval-augmented methods like LeanBridge can improve performance. The benchmark serves as a compact checkpoint for tracking progress in research-level formal theorem proving."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TB\n    A[LeanCat: A Benchmark Suite for Formal Category Theory in Lean] --\x3e B\n    A --\x3e C\n    A --\x3e D\n    B[\u6838\u5fc3\u95ee\u9898/Problem<br>\u73b0\u6709\u57fa\u51c6\u672a\u80fd\u5145\u5206\u8861\u91cf\u62bd\u8c61\u548c\u57fa\u4e8e\u5e93\u7684\u63a8\u7406/Current benchmarks under-measure abstraction and library-mediated reasoning]\n    C[\u4e3b\u8981\u65b9\u6cd5/Method<br>\u4e3aLean\u521b\u5efa\u5f62\u5f0f\u5316\u8303\u7574\u8bba\u57fa\u51c6\uff0c\u5305\u542b100\u4e2a\u5206\u7ea7\u4efb\u52a1/Create a Lean benchmark for formal category theory with 100 graded tasks]\n    D[\u5173\u952e\u7ed3\u679c/Results<br>\u6700\u4f73\u6a21\u578bpass@1\u4e3a8.25%\uff0c\u68c0\u7d22\u589e\u5f3a\u65b9\u6cd5\u6709\u63d0\u5347/Best model pass@1 is 8.25%, retrieval-augmented methods show gains]"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv260101] A Modal Logic for Possibilistic Reasoning with Fuzzy Formal Contexts"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [other], [modal logic], [weighted modal logic, possibilistic reasoning, formal concept analysis, fuzzy formal contexts, rough set theory]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Prosenjit Howlader, Churn-Jung Liau"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," Institute of Information Science, Academia Sinica"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.24980",children:"https://arxiv.org/pdf/2512.24980"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Introduces a novel two-sort weighted modal logic with necessity and sufficiency operators for possibilistic reasoning in fuzzy formal contexts. 2. Provides a sound and complete axiomatization for the logic and its fragments with respect to fuzzy context models. 3. Shows the logic can represent generalized formal, object-oriented, and property-oriented concepts in fuzzy FCA and can be extended to multi-relational contexts."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/0eedb37864559f4df3443ff6f46099ca8b0528be3387a300ecd0f5068e2a25f9_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/0eedb37864559f4df3443ff6f46099ca8b0528be3387a300ecd0f5068e2a25f9_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper introduces a new two-sort weighted modal logic designed for possibilistic reasoning with fuzzy formal contexts, featuring necessity and sufficiency operators. It provides a sound and complete axiomatization for this logic and demonstrates its expressive power by showing it can represent key generalized concepts from Formal Concept Analysis (FCA) in the fuzzy setting. The work also indicates the logic's potential for extension to reasoning with multi-relational fuzzy contexts."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TB\n    Root[\u8bba\u6587\u6807\u9898: A Modal Logic for Possibilistic Reasoning with Fuzzy Formal Contexts] --\x3e Problem\n    Root --\x3e Method\n    Root --\x3e Results\n    Problem[\u6838\u5fc3\u95ee\u9898/Problem: Reasoning with uncertainty in fuzzy formal contexts] --\x3e P1[\u6a21\u7cca\u5f62\u5f0f\u80cc\u666f\u4e2d\u7684\u53ef\u80fd\u6027\u63a8\u7406/Possibilistic reasoning in fuzzy formal contexts]\n    Method[\u4e3b\u8981\u65b9\u6cd5/Method: A two-sort weighted modal logic] --\x3e M1[\u5f15\u5165\u4e24\u79cd\u52a0\u6743\u6a21\u6001\u7b97\u5b50/Introduces two weighted modal operators]\n    M1 --\x3e M1a[\u5fc5\u8981\u6027\u7b97\u5b50/Necessity (\u25a1)]\n    M1 --\x3e M1b[\u5145\u5206\u6027\u7b97\u5b50/Sufficiency (\u229f)]\n    Results[\u5173\u952e\u7ed3\u679c/Results] --\x3e R1[\u903b\u8f91\u662f\u53ef\u9760\u4e14\u5b8c\u5907\u7684/Logic is sound and complete]\n    Results --\x3e R2[\u53ef\u8868\u793aFCA\u4e2d\u7684\u5e7f\u4e49\u6982\u5ff5/Can represent generalized FCA concepts]\n    Results --\x3e R3[\u53ef\u6269\u5c55\u81f3\u591a\u5173\u7cfb\u6a21\u7cca\u80cc\u666f/Extensible to multi-relational contexts]"}),"\n"]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);