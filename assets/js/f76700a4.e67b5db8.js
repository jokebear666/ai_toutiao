"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5892],{28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var s=i(96540);const r={},t=s.createContext(r);function a(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(t.Provider,{value:n},e.children)}},68422:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"daily/cs_LO/20251229-20260104","title":"20251229-20260104 (cs.LO)","description":"2025-12-29","source":"@site/docs/daily/cs_LO/20251229-20260104.md","sourceDirName":"daily/cs_LO","slug":"/daily/cslo/20251229-20260104","permalink":"/ai_toutiao/daily/cslo/20251229-20260104","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767087759000,"frontMatter":{"slug":"/daily/cslo/20251229-20260104"},"sidebar":"tutorialSidebar","previous":{"title":"20251222-20251228 (cs.LO)","permalink":"/ai_toutiao/daily/cslo/20251222-20251228"},"next":{"title":"cs.MA","permalink":"/ai_toutiao/category/csma"}}');var r=i(74848),t=i(28453);const a={slug:"/daily/cslo/20251229-20260104"},o="20251229-20260104 (cs.LO)",l={},c=[{value:"2025-12-29",id:"2025-12-29",level:2},{value:"2025-12-30",id:"2025-12-30",level:2}];function d(e){const n={a:"a",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",mermaid:"mermaid",p:"p",span:"span",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"20251229-20260104-cslo",children:"20251229-20260104 (cs.LO)"})}),"\n",(0,r.jsx)(n.h2,{id:"2025-12-29",children:"2025-12-29"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251229] A Note on the NP-Hardness of PARTITION Via First-Order Projections"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [other], [computational complexity theory], [NP-hardness, first-order reductions, AC0 reductions, PARTITION problem, descriptive complexity]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Pa\xfal Risco Iturralde"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," Independent researcher"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.21448",children:"https://arxiv.org/pdf/2512.21448"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Demonstrates NP-hardness of the PARTITION problem via first-order projections, 2. Overcomes the obstacle of requiring large sums in the standard reduction by using descriptive complexity techniques, 3. Fills a gap in the literature regarding the hardness of PARTITION under restricted reductions like AC0."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/8b5d9f8d4b42755b482904c0cf03df329316dc9a10936a82fe27b6ce034a1e56_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/8b5d9f8d4b42755b482904c0cf03df329316dc9a10936a82fe27b6ce034a1e56_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This note addresses the open question of whether the PARTITION problem is NP-hard under restricted reductions like AC0. It modifies classic reductions from 3SAT to SUBSET-SUM to PARTITION, defining them using first-order logical formulas (first-order projections). The main conclusion is that PARTITION is indeed NP-hard via first-order projections, which implies hardness under polynomial-size AC0 reductions, thereby resolving the gap mentioned in prior work."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TB\n    A[\u8bba\u6587\u6807\u9898: A Note on the NP-Hardness of PARTITION Via First-Order Projections] --\x3e B(\u6838\u5fc3\u95ee\u9898/Problem)\n    A --\x3e C(\u4e3b\u8981\u65b9\u6cd5/Method)\n    A --\x3e D(\u5173\u952e\u7ed3\u679c/Results)\n    B --\x3e B1[PARTITION\u7684NP-hardness\u5728\u53d7\u9650\u5f52\u7ea6\u4e0b\u662f\u5426\u6210\u7acb?/Is PARTITION NP-hard under restricted reductions?]\n    C --\x3e C1[\u4f7f\u7528\u4e00\u9636\u903b\u8f91\u516c\u5f0f\u5b9a\u4e49\u5f52\u7ea6/Define reductions using first-order logic formulas]\n    C --\x3e C2[\u4fee\u6539\u7ecf\u5178\u5f52\u7ea6(3SAT\u5230SUBSET-SUM\u5230PARTITION)/Modify classic reductions (3SAT to SUBSET-SUM to PARTITION)]\n    D --\x3e D1[PARTITION\u5bf9\u4e00\u9636\u6295\u5f71\u662fNP-hard\u7684/PARTITION is NP-hard via first-order projections]\n    D --\x3e D2[\u6697\u793a\u5bf9\u591a\u9879\u5f0f\u5927\u5c0fAC0\u5f52\u7ea6\u4e5f\u662fNP-hard\u7684/Implies NP-hard under polynomial-size AC0 reductions]\n    D --\x3e D3[\u586b\u8865\u4e86\u6587\u732e\u4e2d\u7684\u7a7a\u767d/Fills a gap in the literature]"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251229] Quantitative Verification of Omega-regular Properties in Probabilistic Programming"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [other], [probabilistic programming and verification], [temporal posterior inference, omega-regular properties, stochastic barrier certificates, Rabin automata, quantitative verification]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Peixin Wang, Jianhao Bai, Min Zhang, C.-H. Luke Ong"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," East China Normal University, Nanyang Technological University"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.21596",children:"https://arxiv.org/pdf/2512.21596"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Introduces Temporal Posterior Inference (TPI), a new framework unifying probabilistic programming with temporal logic to compute posterior distributions over execution traces satisfying omega-regular properties. 2. Develops a novel method for computing rigorous upper and lower bounds on satisfaction probabilities by decomposing Rabin acceptance conditions and constructing sound stochastic barrier certificates. 3. Implements the approach in a prototype tool named TPInfer and demonstrates its effectiveness and efficiency on a suite of benchmarks."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/c111a01f9d5e96a85d9b5c62645dae0f5bb40053d723e34cb57dc7f31554dcda_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/c111a01f9d5e96a85d9b5c62645dae0f5bb40053d723e34cb57dc7f31554dcda_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper addresses the limitation of standard probabilistic program inference, which fails to capture temporal behavior, by proposing Temporal Posterior Inference (TPI). TPI computes posterior distributions over program traces that satisfy omega-regular temporal specifications, using a method based on stochastic barrier certificates to provide quantitative verification bounds. The approach is implemented in the TPInfer tool and shown to be effective for inference over rich temporal properties."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:'graph TB\n    Root("Quantitative Verification of Omega-regular Properties in Probabilistic Programming") --\x3e Problem("\u6838\u5fc3\u95ee\u9898/Problem")\n    Root --\x3e Method("\u4e3b\u8981\u65b9\u6cd5/Method")\n    Root --\x3e Results("\u5173\u952e\u7ed3\u679c/Results")\n    Problem --\x3e P1("\u6807\u51c6\u540e\u9a8c\u63a8\u65ad\u7684\u5c40\u9650/Limitation of Standard Posterior Inference")\n    P1 --\x3e P2("\u65e0\u6cd5\u6355\u6349\u7a0b\u5e8f\u6267\u884c\u7684\u65f6\u95f4\u6f14\u5316/Fails to capture temporal evolution")\n    Method --\x3e M1("\u63d0\u51fa\u65f6\u95f4\u540e\u9a8c\u63a8\u65ad\u6846\u67b6/Propose Temporal Posterior Inference (TPI)")\n    M1 --\x3e M2("\u7edf\u4e00\u6982\u7387\u7f16\u7a0b\u4e0e\u65f6\u5e8f\u903b\u8f91/Unifies Probabilistic Programming & Temporal Logic")\n    M2 --\x3e M3("\u57fa\u4e8e\u968f\u673a\u5c4f\u969c\u8bc1\u4e66\u7684\u5b9a\u91cf\u9a8c\u8bc1\u65b9\u6cd5/Quantitative Verification via Stochastic Barrier Certificates")\n    Results --\x3e R1("\u5b9e\u73b0\u539f\u578b\u5de5\u5177 TPInfer/Implement Prototype Tool TPInfer")\n    Results --\x3e R2("\u5728\u57fa\u51c6\u6d4b\u8bd5\u4e2d\u5c55\u793a\u6709\u6548\u6027\u4e0e\u6548\u7387/Demonstrates Effectiveness & Efficiency on Benchmarks")'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251229] First-Order Logic and Twin-Width for Some Geometric Graphs"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [other], [parameterized complexity], [twin-width, first-order logic, model checking, geometric graphs, FPT]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Colin Geniet, Gunwoo Kim, Lucas Meijer"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," Institute for Basic Science (IBS), KAIST, Utrecht University"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.21896",children:"https://arxiv.org/pdf/2512.21896"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Proved that delineation (the equivalence between tractable FO model checking and bounded twin-width) holds for intersection graphs of non-degenerate axis-parallel unit segments. 2. Showed that delineation fails for visibility graphs of 1.5D terrains. 3. Proved delineation for intersection graphs of circular arcs."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/813ec0f508efb48269593ee0f1c17c2ef7df235eda75353b1d1b0c5e93732fd3_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/813ec0f508efb48269593ee0f1c17c2ef7df235eda75353b1d1b0c5e93732fd3_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper investigates the relationship between tractable first-order (FO) logic model checking and the graph parameter twin-width for specific geometric graph classes. It answers open questions by proving this equivalence (delineation) holds for intersection graphs of axis-parallel unit segments and circular arcs, but fails for visibility graphs of 1.5D terrains. The work leverages the theory of twin-width for ordered graphs, exploiting natural vertex orderings in geometric representations."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TB\n    A[First-Order Logic and Twin-Width for Some Geometric Graphs] --\x3e B(\u6838\u5fc3\u95ee\u9898/Problem)\n    A --\x3e C(\u4e3b\u8981\u65b9\u6cd5/Method)\n    A --\x3e D(\u5173\u952e\u7ed3\u679c/Results)\n    B --\x3e B1(\u51e0\u4f55\u56fe\u7c7b\u7684FO\u6a21\u578b\u68c0\u67e5\u590d\u6742\u6027/FO Model Checking Complexity for Geometric Graph Classes)\n    C --\x3e C1(\u5229\u7528\u6709\u5e8f\u56fe\u7684\u53cc\u5bbd\u7406\u8bba/Using Twin-width Theory for Ordered Graphs)\n    D --\x3e D1(\u8bc1\u660e\u8f74\u5e73\u884c\u5355\u4f4d\u7ebf\u6bb5\u56fe\u4e0e\u5706\u5f27\u56fe\u5b58\u5728\u63cf\u7ed8/Prove Delineation for Axis-Parallel Unit Segment & Circular Arc Graphs)\n    D --\x3e D2(\u8bc1\u660e1.5D\u5730\u5f62\u53ef\u89c1\u6027\u56fe\u4e0d\u5b58\u5728\u63cf\u7ed8/Prove Delineation Fails for 1.5D Terrain Visibility Graphs)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251229] The Tensor-Plus Calculus"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [other], [categorical semantics], [graphical language, PROP, monoidal structure, semiring, semiadditive categories]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Kostia Chardonnet, Marc de Visme, Beno\xeet Valiron, Renaud Vilmart"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," Universit\xe9 Paris-Saclay, Universit\xe9 de Lorraine, CentraleSup\xe9lec"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.21965",children:"https://arxiv.org/pdf/2512.21965"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. A novel graphical language with implicit contextual distinction between multiplicative and additive monoidal structures, avoiding explicit annotations. 2. A universal categorical semantics for this language parameterized by a commutative semiring, applicable to non-deterministic, probabilistic, and quantum computation. 3. A sound and complete equational theory that captures semantic equivalence of diagrams."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/2ff122e66fc78c3e6d82c25811f0de1bdfef20eb6e522efbf05297bfacf2592d_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/2ff122e66fc78c3e6d82c25811f0de1bdfef20eb6e522efbf05297bfacf2592d_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," The paper proposes a new graphical calculus that implicitly combines multiplicative (pairing) and additive (branching) monoidal structures within a single, contextually-determined framework. It provides a universal categorical semantics for this language parameterized by a chosen commutative semiring, enabling the modeling of various computational paradigms. The work concludes by establishing a sound and complete equational theory for reasoning about diagram equivalence in this setting."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TB\n    A[The Tensor-Plus Calculus] --\x3e B[\u6838\u5fc3\u95ee\u9898/Problem: How to unify multiplicative and additive structures in a graphical language?]\n    A --\x3e C[\u4e3b\u8981\u65b9\u6cd5/Method: Colored PROP with implicit, contextual structure; semantics parameterized by a commutative semiring.]\n    A --\x3e D[\u5173\u952e\u7ed3\u679c/Results: Universal semantics; sound and complete equational theory for semiadditive categories.]"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251229] Random state comonads encode cellular automata evaluation"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [other], [formal methods & functional programming], [comonad, cellular automata, Haskell, category theory, stochastic]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Madalina I Sas, Julian H J Sutherland"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," Imperial College London"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.22067",children:"https://arxiv.org/pdf/2512.22067"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Introduces an accessible, practical category-theoretical model of Cellular Automata (CA) computation implemented in Haskell. 2. Proposes a novel instantiation of arrays as comonads with state and random generators, enabling the modeling of stochastic CA behavior. 3. Demonstrates the model's generality through case studies of classic 1D and 2D CAs and suggests extensions to N dimensions and arbitrary topologies."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/4dfe9b8ed8e24df98b4c296aebfc6cfdffc4132d68260502b6f113e9e9d43939_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/4dfe9b8ed8e24df98b4c296aebfc6cfdffc4132d68260502b6f113e9e9d43939_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper addresses the gap between abstract formalizations and practical implementations of Cellular Automata (CA). It proposes a functional programming model in Haskell using random state comonads to encode CA evaluation, which supports stochastic behavior and provides a direct mapping between simulation, rules, and categorical theory. The work demonstrates the approach with several classic CA models and suggests it can be generalized to arbitrary topologies."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:'graph TB\n    Root["Random state comonads encode cellular automata evaluation"] --\x3e Problem["\u6838\u5fc3\u95ee\u9898/Problem: Gap between abstract CA theory and practical, feature-rich implementations"]\n    Root --\x3e Method["\u4e3b\u8981\u65b9\u6cd5/Method: Haskell implementation using random state comonads"]\n    Root --\x3e Results["\u5173\u952e\u7ed3\u679c/Results: Accessible model supporting stochastic CA, demonstrated on classic models, extensible to N-D"]'}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"2025-12-30",children:"2025-12-30"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251230] Logic Sketch Prompting (LSP): A Deterministic and Interpretable Prompting Method"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [nlp], [prompt engineering], [Logic Sketch Prompting, deterministic prompting, interpretability, rule adherence, clinical decision support]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Satvik Tripathi"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," University of Pennsylvania"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.22258",children:"https://arxiv.org/pdf/2512.22258"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"code:"})," ",(0,r.jsx)(n.a,{href:"https://github.com/satviktri/LSP",children:"https://github.com/satviktri/LSP"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Proposes Logic Sketch Prompting (LSP), a lightweight prompting framework that introduces typed variables and deterministic condition evaluators for structured reasoning., 2. Incorporates a rule-based validator to produce traceable and repeatable outputs, enhancing auditability., 3. Demonstrates significant performance gains over standard prompting methods (zero-shot, chain-of-thought, concise) on pharmacologic logic-compliance tasks across multiple open-weight LLMs."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/3b5d49d54027e4f7e6b110a48568a0255a45010197e26e8bc344e0cd3e1785a9_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/3b5d49d54027e4f7e6b110a48568a0255a45010197e26e8bc344e0cd3e1785a9_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," The paper addresses the unreliability of LLMs on tasks requiring strict rule adherence and determinism. It proposes Logic Sketch Prompting (LSP), a framework using typed variables and rule-based validation to produce traceable outputs. Evaluations on clinical tasks show LSP significantly outperforms standard prompting methods in accuracy and F1 score, making it suitable for safety-critical systems."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TB\n    A[Logic Sketch Prompting (LSP)] --\x3e B[\u6838\u5fc3\u95ee\u9898/Problem: LLMs unreliable on tasks needing strict rules & determinism]\n    A --\x3e C[\u4e3b\u8981\u65b9\u6cd5/Method: Lightweight framework with typed variables, condition evaluators, rule validator]\n    A --\x3e D[\u5173\u952e\u7ed3\u679c/Results: Highest accuracy/F1 vs. baselines; suitable for clinical/safety-critical systems]"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251230] ReVEAL: GNN-Guided Reverse Engineering for Formal Verification of Optimized Multipliers"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [other], [formal verification, computer algebra], [reverse engineering, graph neural network, multiplier verification, algebraic circuit verification, SAT-based equivalence checking]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Chen Chen, Daniela Kaufmann, Chenhui Deng, Zhan Song, Hongce Zhang, Cunxi Yu"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," University of Maryland, College Park; TU Wien; NVIDIA; Hong Kong University of Science and Technology (Guangzhou)"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.22260",children:"https://arxiv.org/pdf/2512.22260"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Proposes ReVEAL, a graph-learning-based framework for reverse engineering optimized multiplier architectures to recover their word-level structure. 2. Leverages structural graph features and learning-driven inference to identify architectural patterns at scale, enabling robust handling of large, optimized circuits. 3. Integrates smoothly with existing verification flows and supports downstream algebraic proof strategies, showing improvements in scalability and accuracy over traditional rule-based approaches."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/8bdd1907cef6efb0b9b81d88b611f825942f30ef8a8674a9587cc4261e4774ef_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/8bdd1907cef6efb0b9b81d88b611f825942f30ef8a8674a9587cc4261e4774ef_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper introduces ReVEAL, a method that uses Graph Neural Networks (GNNs) to reverse engineer the architecture of optimized hardware multipliers. This recovered structure enables more effective formal verification using algebraic techniques. The approach demonstrates improved scalability and accuracy compared to traditional rule-based methods on diverse benchmarks."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TB\n    A[ReVEAL: GNN-Guided Reverse Engineering for Formal Verification of Optimized Multipliers] --\x3e B(\u6838\u5fc3\u95ee\u9898/Problem: \u4f18\u5316\u4e58\u6cd5\u5668\u5f62\u5f0f\u9a8c\u8bc1\u56f0\u96be/Challenges in formal verification of optimized multipliers)\n    A --\x3e C(\u4e3b\u8981\u65b9\u6cd5/Method: \u57fa\u4e8e\u56fe\u5b66\u4e60\u7684\u9006\u5411\u5de5\u7a0b/GNN-guided reverse engineering)\n    A --\x3e D(\u5173\u952e\u7ed3\u679c/Results: \u63d0\u5347\u53ef\u6269\u5c55\u6027\u4e0e\u51c6\u786e\u6027/Improved scalability and accuracy)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251230] Symbolic Specification and Reasoning for Quantum Data and Operations"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [other], [quantum programming languages & verification], [symbolic logic, formal verification, quantum computation, automated reasoning, SOL]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Mingsheng Ying"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," University of Technology Sydney"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.22383",children:"https://arxiv.org/pdf/2512.22383"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Proposes a novel logical framework called Symbolic Operator Logic (SOL) for symbolic specification of quantum data and operations., 2. Embeds classical first-order logic into SOL to enable reasoning about quantum properties modulo theories of classical data, leveraging existing classical verification tools., 3. Provides a conceptual foundation for formal verification and automated theorem proving of quantum computation in proof assistants like Lean and Coq."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/d170e9ed692953b589cb0ca609b55da71b661300061784405cc0fe9e73f4c680_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/d170e9ed692953b589cb0ca609b55da71b661300061784405cc0fe9e73f4c680_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper addresses the lack of a formal theory for symbolic reasoning in quantum computing by introducing a general logical framework called Symbolic Operator Logic (SOL). The core method embeds classical first-order logic into a language of formal operators for quantum specifications, enabling automated reasoning by reusing classical verification tools. The authors conclude that SOL provides a foundational framework for the formal verification of quantum algorithms and programs."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:'graph TB\n    Root["Symbolic Specification and Reasoning for Quantum Data and Operations"] --\x3e Problem\n    Root --\x3e Method\n    Root --\x3e Results\n    Problem["\u6838\u5fc3\u95ee\u9898/Problem<br>\u7f3a\u4e4f\u91cf\u5b50\u6570\u636e\u4e0e\u64cd\u4f5c\u7684\u5f62\u5f0f\u5316\u7b26\u53f7\u63a8\u7406\u7406\u8bba"] --\x3e P1["\u5bfc\u81f4\u7ed3\u679c/Consequence<br>\u9650\u5236\u91cf\u5b50\u7a0b\u5e8f\u81ea\u52a8\u9a8c\u8bc1\u7684\u5b9e\u7528\u6027"]\n    Method["\u4e3b\u8981\u65b9\u6cd5/Method<br>\u63d0\u51fa\u7b26\u53f7\u7b97\u5b50\u903b\u8f91(SOL)\u6846\u67b6"] --\x3e M1["\u5173\u952e\u6280\u672f/Key Technique<br>\u5c06\u7ecf\u5178\u4e00\u9636\u903b\u8f91\u5d4c\u5165\u5f62\u5f0f\u7b97\u5b50\u8bed\u8a00"]\n    Method --\x3e M2["\u4f18\u52bf/Advantage<br>\u57fa\u4e8e\u7ecf\u5178\u6570\u636e\u7406\u8bba(\u5982\u5e03\u5c14\u4ee3\u6570)\u8fdb\u884c\u63a8\u7406"]\n    Results["\u5173\u952e\u7ed3\u679c/Results<br>\u4e3a\u91cf\u5b50\u8ba1\u7b97\u5f62\u5f0f\u9a8c\u8bc1\u63d0\u4f9b\u6982\u5ff5\u57fa\u7840"] --\x3e R1["\u5e94\u7528\u524d\u666f/Application<br>\u7528\u4e8eLean, Coq\u7b49\u8bc1\u660e\u52a9\u624b"]'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251230] A Representation of Explicit Knowledge and Epistemic Indistinguishability in a Logic of Awareness"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [other], [epistemic logic], [awareness logic, explicit knowledge, logical omniscience, modal logic, completeness]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Yudai Kubono, Satoshi Tojo"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," Shizuoka University, Asia University"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.22477",children:"https://arxiv.org/pdf/2512.22477"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Proposes a refined definition of explicit knowledge in awareness logic that addresses undesirable derivations from Modus Ponens in implicit knowledge, 2. Introduces a new formal logic called Awareness-Based Indistinguishability Logic (AIL) with enhanced expressive power over the Fagin-Halpern logic, 3. Provides a sound and complete axiomatic system for AIL."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/ee03db160587ff877ac6134a739d58ab248a7f54166c46721902cd24c89d04bf_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/ee03db160587ff877ac6134a739d58ab248a7f54166c46721902cd24c89d04bf_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper addresses a flaw in the classic logic of awareness by Fagin and Halpern, where their definition of explicit knowledge can lead to undesirable conclusions. The authors propose a new logic called Awareness-Based Indistinguishability Logic (AIL), which refines the definition by linking indistinguishability of possible worlds to awareness. They prove AIL is more expressive than the prior logic and provide a sound and complete axiomatic system for it."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:'graph TB\n    A["A Representation of Explicit Knowledge and Epistemic Indistinguishability in a Logic of Awareness<br>\u8bba\u6587\u6807\u9898"] --\x3e B["\u6838\u5fc3\u95ee\u9898/Problem<br>Fagin-Halpern\u903b\u8f91\u4e2d\u663e\u5f0f\u77e5\u8bc6\u7684\u5b9a\u4e49\u53ef\u80fd\u5bfc\u81f4\u4e0d\u826f\u63a8\u8bba"]\n    A --\x3e C["\u4e3b\u8981\u65b9\u6cd5/Method<br>\u63d0\u51fa\u57fa\u4e8e\u610f\u8bc6\u7684\u4e0d\u53ef\u533a\u5206\u6027\u903b\u8f91(AIL)\uff0c\u7cbe\u786e\u5b9a\u4e49\u663e\u5f0f\u77e5\u8bc6"]\n    A --\x3e D["\u5173\u952e\u7ed3\u679c/Results<br>AIL\u66f4\u5177\u8868\u8fbe\u529b\uff0c\u53ef\u5d4c\u5165\u539f\u903b\u8f91\uff0c\u5e76\u5177\u5907\u53ef\u9760\u4e14\u5b8c\u5907\u7684\u516c\u7406\u7cfb\u7edf"]'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251230] Many-valued coalgebraic dynamic logics: Safety and strong completeness via reducibility"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [other], [formal methods], [coalgebraic modal logic, many-valued logic, dynamic logic, bisimulation safety, strong completeness]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Helle Hvid Hansen, Wolfgang Poiger"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," University of Groningen, Institute of Computer Science of the Czech Academy of Sciences"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.22851",children:"https://arxiv.org/pdf/2512.22851"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Proposes a coalgebraic framework for generalizing dynamic modal logics (like PDL and game logic) to many-valued settings where both propositions and semantic structures can take truth-degrees from an FLew-algebra. 2. Introduces the concept of reducible coalgebra operations and tests, proving that such operations are safe for bisimulation and behavioural equivalence. 3. Proves a general strong completeness theorem for the framework, leading to new strong completeness results for specific logics like 2-valued iteration-free PDL with many-valued accessibility relations and many-valued iteration-free game logic."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/3befe5f4bde38d3dda7c5a9f23902f5621b1316b62c6e3e2b1f3e208c172be1e_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/3befe5f4bde38d3dda7c5a9f23902f5621b1316b62c6e3e2b1f3e208c172be1e_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper presents a coalgebraic framework for generalizing dynamic modal logics to many-valued settings. It focuses on operations that are reducible, meaning modalities for composed actions can be reduced to compositions of simpler modalities, and proves these operations are safe for bisimulation and lead to strong completeness. The results yield new completeness theorems for specific many-valued versions of PDL and game logic."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TB\n    A[Many-valued Coalgebraic Dynamic Logics] --\x3e B[\u6838\u5fc3\u95ee\u9898/Problem: Generalizing dynamic logics (PDL, game logic) to many-valued settings]\n    A --\x3e C[\u4e3b\u8981\u65b9\u6cd5/Method: Coalgebraic framework with A-valued predicate liftings and reducible operations]\n    A --\x3e D[\u5173\u952e\u7ed3\u679c/Results: Reducible operations are safe for bisimulation; general strong completeness theorem proven]"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251230] PSPACE-Completeness of the Equational Theory of Relational Kleene Algebra with Graph Loop"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [other], [Formal Languages and Automata Theory], [Kleene algebra, graph loop, PSpace-completeness, loop-automata, equational theory]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Yoshiki Nakamura"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," Institute of Science Tokyo"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.22930",children:"https://arxiv.org/pdf/2512.22930"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Proved that the equational theory of relational Kleene algebra with the graph loop operator is PSpace-complete. 2. Introduced a novel automaton model called loop-automata to facilitate the complexity analysis. 3. Established a polynomial-time reduction from the equational theories to the language inclusion problem for 2-way alternating string automata."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/143a4383124a50a9271d22d401dedf3a296d859fe9ccfaf34be96747d60ca607_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/143a4383124a50a9271d22d401dedf3a296d859fe9ccfaf34be96747d60ca607_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper investigates the computational complexity of the equational theory for relational Kleene algebra extended with a graph loop operator. The authors introduce a new automaton model called loop-automata and use it to provide a polynomial-time reduction to a known automata problem. The main result is proving that this equational theory is PSpace-complete, a complexity that persists even with several other extensions."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TB\n    Root[PSPACE-Completeness of the Equational Theory of Relational Kleene Algebra with Graph Loop] --\x3e Problem\n    Root --\x3e Method\n    Root --\x3e Results\n    Problem[\u6838\u5fc3\u95ee\u9898/Problem: Which extensions of Relational Kleene Algebra (RKA) keep PSpace-complete equational theory?]\n    Method[\u4e3b\u8981\u65b9\u6cd5/Method: Introduce loop-automata; Reduce to 2-way alternating automata inclusion problem]\n    Results[\u5173\u952e\u7ed3\u679c/Results: Equational theory of loop-RKA is PSpace-complete; Result holds with top, tests, converse, nominals]"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251230] Hypergraph Semantics for Doxastic Logics"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [other], [modal logic], [directed hypergraphs, doxastic logic, simplicial models, canonical models, Kripke models]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Hans van Ditmarsch, Djanira Gomes, David Lehnherr, Valentin M\xfcller, Thomas Studer"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," CNRS, IRIT, University of Toulouse, University of Bern"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.23088",children:"https://arxiv.org/pdf/2512.23088"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Introduces a new semantics for logics of belief based on directed hypergraphs, extending beyond the knowledge-only representation of simplicial models. 2. Provides complete axiomatizations for systems of both consistent belief and merely introspective belief, proven via the construction of canonical hypergraph models. 3. Presents direct conversion methods between traditional doxastic Kripke models and the new directed hypergraph models."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/9148e7fe21d36571fcaa8501e6f6f8e914b61b99c9fad3c304b84d0731e14147_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/9148e7fe21d36571fcaa8501e6f6f8e914b61b99c9fad3c304b84d0731e14147_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper addresses the limitation of simplicial models, which can represent knowledge but not beliefs in distributed systems. It proposes a new semantics for belief logics using directed hypergraphs, which retain the structural benefits of simplicial models while accommodating agent beliefs. The work establishes complete axiomatizations for belief systems and shows how the new models relate to standard Kripke models."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:'graph TB\n    Root("Hypergraph Semantics for Doxastic Logics<br/>\u8d85\u56fe\u8bed\u4e49\u7528\u4e8e\u4fe1\u5ff5\u903b\u8f91") --\x3e Problem("\u6838\u5fc3\u95ee\u9898/Problem")\n    Root --\x3e Method("\u4e3b\u8981\u65b9\u6cd5/Method")\n    Root --\x3e Results("\u5173\u952e\u7ed3\u679c/Results")\n    Problem --\x3e P1("Simplicial models cannot represent beliefs<br/>\u5355\u7eaf\u590d\u5f62\u6a21\u578b\u65e0\u6cd5\u8868\u793a\u4fe1\u5ff5")\n    Method --\x3e M1("New semantics using directed hypergraphs<br/>\u4f7f\u7528\u6709\u5411\u8d85\u56fe\u7684\u65b0\u8bed\u4e49")\n    Results --\x3e R1("Complete axiomatizations for belief systems<br/>\u4fe1\u5ff5\u7cfb\u7edf\u7684\u5b8c\u5907\u516c\u7406\u5316")\n    Results --\x3e R2("Conversions to/from Kripke models<br/>\u4e0e\u514b\u91cc\u666e\u514b\u6a21\u578b\u7684\u76f8\u4e92\u8f6c\u6362")'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["[arXiv251230] On Conformant Planning and Model-Checking of ",(0,r.jsx)(n.span,{className:"katex-error",title:"ParseError: KaTeX parse error: Double superscript at position 3: ^*^\u0332*",style:{color:"#cc0000"},children:"^*^*"})," Hyperproperties"]})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [other], [formal methods], [conformant planning, hyperproperties, model-checking, HyperLTL, \u2203\u2217\u2200\u2217]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Raven Beutner, Bernd Finkbeiner"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," CISPA Helmholtz Center for Information Security"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.23324",children:"https://arxiv.org/pdf/2512.23324"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Establishes a formal connection between conformant planning and model-checking of \u2203\u2217\u2200\u2217 hyperproperties, showing they share the same computational core. 2. Provides an efficient, sound, and complete reduction from a hyperproperty model-checking instance to a conformant planning instance. 3. Demonstrates that every conformant planning problem is itself a hyperproperty model-checking task, establishing the converse direction."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/47343ca7bc4bf16389257261dd21e0c1fa42c0f512178576ff4ba501df841e8b_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/47343ca7bc4bf16389257261dd21e0c1fa42c0f512178576ff4ba501df841e8b_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper identifies and formalizes a deep connection between two seemingly unrelated problems: conformant planning (finding a robust sequential plan under uncertainty) and model-checking of \u2203\u2217\u2200\u2217 hyperproperties (verifying system properties that relate multiple execution traces). The authors provide efficient, sound, and complete translations between instances of these two problems, showing they are essentially two sides of the same computational coin. This foundational link aims to enable cross-pollination of solution techniques between the planning and verification communities."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TB\n    A[On Conformant Planning and Model-Checking of \u2203\u2217\u2200\u2217 Hyperproperties] --\x3e B(\u6838\u5fc3\u95ee\u9898/Problem)\n    A --\x3e C(\u4e3b\u8981\u65b9\u6cd5/Method)\n    A --\x3e D(\u5173\u952e\u7ed3\u679c/Results)\n    B --\x3e B1[\u8fde\u63a5\u4e24\u4e2a\u770b\u4f3c\u65e0\u5173\u7684\u95ee\u9898 / Linking two seemingly unrelated problems]\n    B1 --\x3e B2[Conformant Planning / \u4e00\u81f4\u6027\u89c4\u5212]\n    B1 --\x3e B3[Hyperproperty Model-Checking / \u8d85\u5c5e\u6027\u6a21\u578b\u68c0\u6d4b]\n    C --\x3e C1[\u6784\u5efa\u53cc\u5411\u9ad8\u6548\u89c4\u7ea6 / Constructing bidirectional efficient reductions]\n    D --\x3e D1[\u8bc1\u660e\u89c4\u7ea6\u7684\u53ef\u9760\u6027\u4e0e\u5b8c\u5907\u6027 / Proving reductions are sound and complete]\n    D --\x3e D2[\u786e\u7acb\u95ee\u9898\u7684\u7b49\u4ef7\u6027 / Establishing the equivalence of the problems]"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251230] Checking Satisfiability of Hyperproperties using First-Order Logic"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [sec], [formal verification], [hyperproperties, HyperLTL, satisfiability checking, first-order logic, FOLHyper]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Raven Beutner, Bernd Finkbeiner"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," CISPA Helmholtz Center for Information Security"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.23332",children:"https://arxiv.org/pdf/2512.23332"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Introduces FOLHyper, a tool for automatically checking the satisfiability of hyperproperties specified in HyperLTL. 2. Reduces the HyperLTL satisfiability problem to an equisatisfiable first-order logic formula, enabling the use of standard FOL solvers. 3. Extends applicability beyond the decidable \u2203",(0,r.jsx)(n.em,{children:"\u2200"})," fragment of HyperLTL and is shown to be particularly effective at proving unsatisfiability, complementing existing bounded methods."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/1df9c7eeb320b67a7ee7c2bfb2c3c7df8d5c7c6cfd6201d5246d2ea403911999_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/1df9c7eeb320b67a7ee7c2bfb2c3c7df8d5c7c6cfd6201d5246d2ea403911999_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper addresses the problem of checking the satisfiability of hyperproperties, which are crucial for security and information-flow specifications. It proposes FOLHyper, a tool that translates HyperLTL formulas into equisatisfiable first-order logic formulas, allowing the use of FOL solvers for analysis. The method extends beyond known decidable fragments and is shown to be effective, especially for proving unsatisfiability."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TB\n    A[Checking Satisfiability of Hyperproperties using First-Order Logic] --\x3e B[\u6838\u5fc3\u95ee\u9898/Problem: \u8d85\u5c5e\u6027\u53ef\u6ee1\u8db3\u6027\u68c0\u67e5/Hyperproperty Satisfiability Checking]\n    A --\x3e C[\u4e3b\u8981\u65b9\u6cd5/Method: \u5c06HyperLTL\u7ea6\u7b80\u4e3a\u4e00\u9636\u903b\u8f91\u516c\u5f0f/Reduce HyperLTL to FOL]\n    A --\x3e D[\u5173\u952e\u7ed3\u679c/Results: FOLHyper\u5de5\u5177\uff0c\u6709\u6548\u8bc1\u660e\u4e0d\u53ef\u6ee1\u8db3\u6027/FOLHyper Tool, Effective for Unsatisfiability]"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251230] Verifying Asynchronous Hyperproperties in Reactive Systems"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [sec], [formal verification], [asynchronous hyperproperties, HyperLTL, model checking, game semantics, observational determinism]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Raven Beutner, Bernd Finkbeiner"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," CISPA Helmholtz Center for Information Security"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.23344",children:"https://arxiv.org/pdf/2512.23344"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Proposes a novel game-based approach for verifying arbitrary \u2200\u2217\u2203\u2217 formulas in Asynchronous HyperLTL (A-HLTL) in reactive systems. 2. Interprets verification as a game between a verifier and refuter, where a winning strategy provides witnesses for traces and asynchronous alignments for stutterings. 3. Identifies fragments for which the game-based interpretation is complete, providing a finite-state decision procedure, and contributes a prototype implementation with encouraging experimental results."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/0e321908ac7277c8c91e3b8e509efae3be66dbe7c391e613f19a6ca343db4f16_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/0e321908ac7277c8c91e3b8e509efae3be66dbe7c391e613f19a6ca343db4f16_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This paper addresses the challenge of model-checking asynchronous hyperproperties in reactive systems, which require comparing execution traces across different timesteps. It proposes a novel game-based verification method for a logic called Asynchronous HyperLTL (A-HLTL), interpreting the problem as a two-player game to find suitable trace stutterings. The approach provides a decision procedure for certain formula fragments and is supported by a prototype implementation."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TB\n    Root[Verifying Asynchronous Hyperproperties in Reactive Systems] --\x3e Problem\n    Root --\x3e Method\n    Root --\x3e Results\n    Problem[\u6838\u5fc3\u95ee\u9898/Problem] --\x3e P1[\u540c\u6b65HyperLTL\u65e0\u6cd5\u8868\u8fbe\u5f02\u6b65\u8d85\u5c5e\u6027/Synchronous HyperLTL cannot express asynchronous hyperproperties]\n    Problem --\x3e P2[\u73b0\u6709\u65b9\u6cd5\u9650\u5236\u4e8e\u53d7\u9650\u7247\u6bb5\u6216\u7ec8\u6b62\u7cfb\u7edf/Existing methods limited to restricted fragments or terminating systems]\n    Method[\u4e3b\u8981\u65b9\u6cd5/Method] --\x3e M1[\u63d0\u51fa\u57fa\u4e8e\u6e38\u620f\u7684\u9a8c\u8bc1\u65b9\u6cd5/Propose a game-based verification approach]\n    Method --\x3e M2[\u9a8c\u8bc1\u8005\u4e0e\u53cd\u9a73\u8005\u7684\u53cc\u4eba\u6e38\u620f/Two-player game between verifier and refuter]\n    Method --\x3e M3[\u83b7\u80dc\u7b56\u7565\u5bf9\u5e94\u5b58\u5728\u91cf\u5316\u7684\u8bc1\u636e/Winning strategy corresponds to witnesses for existential quantification]\n    Results[\u5173\u952e\u7ed3\u679c/Results] --\x3e R1[\u4e3a\u2200\u2217\u2203\u2217 A-HLTL\u516c\u5f0f\u63d0\u4f9b\u65b9\u6cd5/Provides method for arbitrary \u2200\u2217\u2203\u2217 A-HLTL formulas]\n    Results --\x3e R2[\u8bc6\u522b\u5b8c\u5168\u6027\u7684\u7247\u6bb5/Identifies fragments for which the interpretation is complete]\n    Results --\x3e R3[\u539f\u578b\u5b9e\u73b0\u4e0e\u5b9e\u9a8c\u7ed3\u679c/Prototype implementation and experimental results]"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"[arXiv251230] Modelling of logical systems by means of their fragments"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"tags:"})," [other], [computational logic], [superintuitionistic logics, modal logics, complexity reduction, Kripke incompleteness, predicate calculi]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"authors:"})," Mikhail Rybakov"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"institution:"})," Moscow Institute of Physics and Technology (MIPT)"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"link:"})," ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/2512.23509",children:"https://arxiv.org/pdf/2512.23509"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"contributions:"})," 1. Proved polynomial-time reducibility of propositional logics to their fragments with at most two variables. 2. Established reducibility of predicate logics to fragments with limited predicate letters and individual variables, with conditions and counterexamples. 3. Provided new complexity bounds, Kripke-incompleteness results, and analogues of Church and Trakhtenbrot theorems for quasiary predicate logic."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"thumbnail:"})," ",(0,r.jsx)(n.a,{href:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/6250c5fb6676c8f8ac8f9a2e9bc581ee4e2c8b46c6236e4948549173497931aa_w640_q70.webp",children:"https://pub-9ba4a5dae3bf4fc7b7d26411a74e92db.r2.dev/thumbnails/6250c5fb6676c8f8ac8f9a2e9bc581ee4e2c8b46c6236e4948549173497931aa_w640_q70.webp"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple LLM Summary:"})," This work investigates the algorithmic complexity of non-classical logics. It demonstrates that many propositional and predicate logics can be reduced to simpler, smaller fragments, establishing conditions for such reductions and providing counterexamples. The results include new complexity bounds and fundamental incompleteness theorems for these logical systems."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mindmap:"})}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TB\n    A[Modelling of logical systems by means of their fragments] --\x3e B(\u6838\u5fc3\u95ee\u9898/Problem: Algorithmic complexity of non-classical logics)\n    A --\x3e C(\u4e3b\u8981\u65b9\u6cd5/Method: Reduction to simpler fragments)\n    A --\x3e D(\u5173\u952e\u7ed3\u679c/Results: Complexity bounds, reducibility conditions, incompleteness theorems)"}),"\n"]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);